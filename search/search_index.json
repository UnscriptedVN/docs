{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 The Unscripted Documentation Center offers a centralized, easy-to-use place to browse and read up on documentation for Unscripted's in-house projects. Current Projects \u00b6 Core \u00b6 Unscripted Core is the core logic of the game that we've open-sourced to the public. As the game's development continues, this code is updated. The core contains features such as themes, minigame logic, and other tools. Fira \u00b6 Fira is the backend and user-facing API code for Unscripted's minigame. Fira contains the utilities to read and generate minigame level data from a configuration file. It also contains the backend logic for NadiaVM, the minigame's stack-based virtual machine. Simple Changes \u00b6 Simple Changes is a dead-simple changelog format designed for parsing and ease of use. It makes use of a TOML-like syntax and makes it easy to parse. Our Python package, simplechanges , also offers a parser to let you get information for any version requested. Ren'Py Distribution Tools \u00b6 The Ren'Py Distribution Tools is a Python module that aims to make distributing Ren'Py projects easier, programmatically. Inject data into your VN's macOS property list, code sign and notarize your macOS app, and upload to Itch.io by writing a simple Python script.","title":"Welcome"},{"location":"#welcome","text":"The Unscripted Documentation Center offers a centralized, easy-to-use place to browse and read up on documentation for Unscripted's in-house projects.","title":"Welcome"},{"location":"#current-projects","text":"","title":"Current Projects"},{"location":"#core","text":"Unscripted Core is the core logic of the game that we've open-sourced to the public. As the game's development continues, this code is updated. The core contains features such as themes, minigame logic, and other tools.","title":"Core"},{"location":"#fira","text":"Fira is the backend and user-facing API code for Unscripted's minigame. Fira contains the utilities to read and generate minigame level data from a configuration file. It also contains the backend logic for NadiaVM, the minigame's stack-based virtual machine.","title":"Fira"},{"location":"#simple-changes","text":"Simple Changes is a dead-simple changelog format designed for parsing and ease of use. It makes use of a TOML-like syntax and makes it easy to parse. Our Python package, simplechanges , also offers a parser to let you get information for any version requested.","title":"Simple Changes"},{"location":"#renpy-distribution-tools","text":"The Ren'Py Distribution Tools is a Python module that aims to make distributing Ren'Py projects easier, programmatically. Inject data into your VN's macOS property list, code sign and notarize your macOS app, and upload to Itch.io by writing a simple Python script.","title":"Ren'Py Distribution Tools"},{"location":"core/","text":"The core logic of Unscripted \u00b6 Unscripted Core contains the source code for most, if not all, of the logic for the game. This logic includes, but is not limited to: User interface controls, themes, and splash screens Credits sequencing, lexer, and display mechanism Definitions for images and audio Minigame frontend logic not covered by Fira Open-sourced assets such as images and audio Classes and logic for player data Logic for build configurations Why open-source? \u00b6 I anticipate that some players and developers may want to better understand how I do some things in Unscripted or may want to contribute to the project to catch any bugs. I want to make Unscripted a place to go to learn new things and try out what's available with Python and Ren'Py just like how I did when making mods for DDLC, so I've decided that I will be open-sourcing some core utilities and modules inside of the game itself known as the Unscripted Core. - Captain's Devlog: May-June 2020 Getting started \u00b6 To get started, clone this repository into a Ren'Py project or Unscripted mod in the core folder. The files will automatically be compiled with Unscripted. Warning Unscripted Core is still under heavy development and the overall structure/inner workings of the project will change over time. Installing dependencies \u00b6 Unscripted Core (and the game, subsequently) rely on some Python packages to operate properly. The required dependencies are listed in requirements.txt. To install these dependencies, run the following*: pip install -r path/to/core/requirements.txt --target game/python-packages Info Unscripted is currently built with Ren'Py 7.3.5, which requires that these packages be Python 2-compatible. Run the pip command in a Python 2 environment, either from your system or the provided Python environment in Ren'Py.","title":"Home"},{"location":"core/#the-core-logic-of-unscripted","text":"Unscripted Core contains the source code for most, if not all, of the logic for the game. This logic includes, but is not limited to: User interface controls, themes, and splash screens Credits sequencing, lexer, and display mechanism Definitions for images and audio Minigame frontend logic not covered by Fira Open-sourced assets such as images and audio Classes and logic for player data Logic for build configurations","title":"The core logic of Unscripted"},{"location":"core/#why-open-source","text":"I anticipate that some players and developers may want to better understand how I do some things in Unscripted or may want to contribute to the project to catch any bugs. I want to make Unscripted a place to go to learn new things and try out what's available with Python and Ren'Py just like how I did when making mods for DDLC, so I've decided that I will be open-sourcing some core utilities and modules inside of the game itself known as the Unscripted Core. - Captain's Devlog: May-June 2020","title":"Why open-source?"},{"location":"core/#getting-started","text":"To get started, clone this repository into a Ren'Py project or Unscripted mod in the core folder. The files will automatically be compiled with Unscripted. Warning Unscripted Core is still under heavy development and the overall structure/inner workings of the project will change over time.","title":"Getting started"},{"location":"core/#installing-dependencies","text":"Unscripted Core (and the game, subsequently) rely on some Python packages to operate properly. The required dependencies are listed in requirements.txt. To install these dependencies, run the following*: pip install -r path/to/core/requirements.txt --target game/python-packages Info Unscripted is currently built with Ren'Py 7.3.5, which requires that these packages be Python 2-compatible. Run the pip command in a Python 2 environment, either from your system or the provided Python environment in Ren'Py.","title":"Installing dependencies"},{"location":"core/arguments/","text":"Arguments File \u00b6 Since Unscripted doesn't support command-line arguments presently, players and developers can create an arguments file that will act as command line arguments. Unscripted will search for an arguments file at the root of the game's files, arguments.toml : Unscripted/ scripts.rpa images.rpa logic.rpa arguments.toml For macOS builds, you may need to right-click on the app and select \"Show Package Contents\", then navigate to Contents/Resources/game/. The arguments should contain a single dictionary at the root, args . The following are the allowed keys in the arguments file: init_dreams : Whether to initialize the dreams folder in the game files if Dreams are enabled. disable-minigame : Whether to disable the minigame and prevent it from running at all. disable_experiments : Defines the list of experiments to turn off when running the game. Should be a list of strings that matches the experiments defined in the build configuration. Example \u00b6 [args] disable_experiments = [ \"enable-glossary\" ]","title":"Arguments File"},{"location":"core/arguments/#arguments-file","text":"Since Unscripted doesn't support command-line arguments presently, players and developers can create an arguments file that will act as command line arguments. Unscripted will search for an arguments file at the root of the game's files, arguments.toml : Unscripted/ scripts.rpa images.rpa logic.rpa arguments.toml For macOS builds, you may need to right-click on the app and select \"Show Package Contents\", then navigate to Contents/Resources/game/. The arguments should contain a single dictionary at the root, args . The following are the allowed keys in the arguments file: init_dreams : Whether to initialize the dreams folder in the game files if Dreams are enabled. disable-minigame : Whether to disable the minigame and prevent it from running at all. disable_experiments : Defines the list of experiments to turn off when running the game. Should be a list of strings that matches the experiments defined in the build configuration.","title":"Arguments File"},{"location":"core/arguments/#example","text":"[args] disable_experiments = [ \"enable-glossary\" ]","title":"Example"},{"location":"core/build/","text":"Build Configuration \u00b6 Unscripted Core uses a build configuration file to handle versioning, channels, and enabling/disabling specific files in the game. This configuration, build.toml , should live in the root of the game's files. When Unscripted runs, it will read from this file and store the configuration in a Python dictionary uconf . The following is a document that outlines all of the possible fields and information inside the build configuration file. Warning The build configuration file is still a work-in-progress. Fields and information may change over time. Information \u00b6 The info section controls the versioning information and release channels for the game. There are two primary keys used in the info section of the build file: version - Defines the game's version, such as 1.2.3 . This is exposed here to allow easy manipulation in external processes such as CI deployments. channel - Defines the release channel. Typically, there are two channels used: \"stable\" and \"beta\" . If the game is started via the Ren'Py SDK, the channel is set to \"canary\" . [config.info] version = \"1.2.3\" channel = \"stable\" Features \u00b6 The features section controls what features are enabled in the game by default. The following keys exist in the features section: enable_dreams - Whether the Dreams modding functionality should be enabled. enable_minigame_adv_mode - Whether to enable the minigame's advanced mode. This does not turn the feature on, but it allows for the option to exist in the game. [config.features] enable_dreams = false enable_youtrack_link = true enable_minigame_adv_mode = true Labs \u00b6 The labs section controls experimental features. There currently is a single key, current , which contains a list of strings for the experiments that will be enabled in the game. [config.labs] current = [ \"enable-glossary\" ] Analytics \u00b6 The analytics section controls the features for the bug reports and analytics data. enable_bug_reports - Whether or not to show the bug report links in the game menu. Replaces enable_youtrack_link in features. survey_link - Defines the survey link at the end of the game. If this key is included, a prompt will appear at the end of the game that encourages players to take a survey about the game. links - Defines the bug reporting links. This dictionary should contain fields for the stable and beta release channels. [config.analytics] enable_bug_reports = true survey_link = \"https://go-to-my-survey.com\" [config.analytics.links] stable = \"https://github.com/UnscriptedVN/issues/issues/new/choose\" beta = \"https://github.com/UnscriptedVN/game/issues/new/choose\" Discord \u00b6 The Discord section controls the Rich Presence feature in the game. There are two keys present: enable_rpc - Whether the Rich Presence client should be enabled. client_id - Defines the Discord Rich Presence client's ID. This client must contain the images necessary for the game. [config.discord] enable_rpc = true client_id = \"000000000000000000\" Demo \u00b6 The demo section controls different aspects of the demo version of the game. demo - Whether this build is a demo release. demo_max_count - Defines the maximum number of chapters that should be accessible in the game. demo_bundle_core - Whether the game should make an archive containing the source code to the Unscripted Core. [config.demo] demo = false demo_max_count = 6 demo_bundle_core = false","title":"Build Configuration"},{"location":"core/build/#build-configuration","text":"Unscripted Core uses a build configuration file to handle versioning, channels, and enabling/disabling specific files in the game. This configuration, build.toml , should live in the root of the game's files. When Unscripted runs, it will read from this file and store the configuration in a Python dictionary uconf . The following is a document that outlines all of the possible fields and information inside the build configuration file. Warning The build configuration file is still a work-in-progress. Fields and information may change over time.","title":"Build Configuration"},{"location":"core/build/#information","text":"The info section controls the versioning information and release channels for the game. There are two primary keys used in the info section of the build file: version - Defines the game's version, such as 1.2.3 . This is exposed here to allow easy manipulation in external processes such as CI deployments. channel - Defines the release channel. Typically, there are two channels used: \"stable\" and \"beta\" . If the game is started via the Ren'Py SDK, the channel is set to \"canary\" . [config.info] version = \"1.2.3\" channel = \"stable\"","title":"Information"},{"location":"core/build/#features","text":"The features section controls what features are enabled in the game by default. The following keys exist in the features section: enable_dreams - Whether the Dreams modding functionality should be enabled. enable_minigame_adv_mode - Whether to enable the minigame's advanced mode. This does not turn the feature on, but it allows for the option to exist in the game. [config.features] enable_dreams = false enable_youtrack_link = true enable_minigame_adv_mode = true","title":"Features"},{"location":"core/build/#labs","text":"The labs section controls experimental features. There currently is a single key, current , which contains a list of strings for the experiments that will be enabled in the game. [config.labs] current = [ \"enable-glossary\" ]","title":"Labs"},{"location":"core/build/#analytics","text":"The analytics section controls the features for the bug reports and analytics data. enable_bug_reports - Whether or not to show the bug report links in the game menu. Replaces enable_youtrack_link in features. survey_link - Defines the survey link at the end of the game. If this key is included, a prompt will appear at the end of the game that encourages players to take a survey about the game. links - Defines the bug reporting links. This dictionary should contain fields for the stable and beta release channels. [config.analytics] enable_bug_reports = true survey_link = \"https://go-to-my-survey.com\" [config.analytics.links] stable = \"https://github.com/UnscriptedVN/issues/issues/new/choose\" beta = \"https://github.com/UnscriptedVN/game/issues/new/choose\"","title":"Analytics"},{"location":"core/build/#discord","text":"The Discord section controls the Rich Presence feature in the game. There are two keys present: enable_rpc - Whether the Rich Presence client should be enabled. client_id - Defines the Discord Rich Presence client's ID. This client must contain the images necessary for the game. [config.discord] enable_rpc = true client_id = \"000000000000000000\"","title":"Discord"},{"location":"core/build/#demo","text":"The demo section controls different aspects of the demo version of the game. demo - Whether this build is a demo release. demo_max_count - Defines the maximum number of chapters that should be accessible in the game. demo_bundle_core - Whether the game should make an archive containing the source code to the Unscripted Core. [config.demo] demo = false demo_max_count = 6 demo_bundle_core = false","title":"Demo"},{"location":"core/statements/","text":"Custom Statements \u00b6 Unscripted Core introduces a few custom statements to make managing the game easier. This document is a running list of the statements added and their arguments, respectively. musiclayer push track_name channel \u00b6 Push a given track to the specified audio channel, with respect to the music channel. If the music channel is playing, the music layer will determine where the audio position is and play the file from that point. Fades are automatically applied. track_name : The filepath or audio definition to play in the given channel. channel : The audio channel to play the track in. musiclayer pop channel \u00b6 Pop the current track from the specified audio channel. Fades are automatically applied. channel : The audio channel to stop playing music from. puzzle number \u00b6 Run the minigame puzzle with the corresponding level number. If disable-minigame is present in the arguments manifest or \"Enable minigame experience\" in user settings is disabled, this command will effectively do nothing. number : The level number to run, starting from 0.","title":"Custom Statements"},{"location":"core/statements/#custom-statements","text":"Unscripted Core introduces a few custom statements to make managing the game easier. This document is a running list of the statements added and their arguments, respectively.","title":"Custom Statements"},{"location":"core/statements/#musiclayer-push-track_name-channel","text":"Push a given track to the specified audio channel, with respect to the music channel. If the music channel is playing, the music layer will determine where the audio position is and play the file from that point. Fades are automatically applied. track_name : The filepath or audio definition to play in the given channel. channel : The audio channel to play the track in.","title":"musiclayer push track_name channel"},{"location":"core/statements/#musiclayer-pop-channel","text":"Pop the current track from the specified audio channel. Fades are automatically applied. channel : The audio channel to stop playing music from.","title":"musiclayer pop channel"},{"location":"core/statements/#puzzle-number","text":"Run the minigame puzzle with the corresponding level number. If disable-minigame is present in the arguments manifest or \"Enable minigame experience\" in user settings is disabled, this command will effectively do nothing. number : The level number to run, starting from 0.","title":"puzzle number"},{"location":"core/themes/","text":"Theming \u00b6 Unscripted supports the creation and usage of themes which manage the overall look of the game and its interface. Themes are defined as a directory with a manifest and subdirectories of image files that contain the interface elements. Default themes \u00b6 There are four themes that ship with Unscripted: Ayu Light Blue ( ruby-light ) Ayu Mirage Blue ( ruby-mirage ) Ayu Dark Blue ( ruby-dark ) Ring ( ring ) All Ayu themes are variants of the Ayu color scheme with the accent color changed to the Unscripted blue color. Ring is the original Unscripted theme before the theme overhaul. The game will try to set ring as the default interface theme if no theme is present. In the game's settings under Appearance , the game will allow players to select from any of the Ayu themes. Creating a theme \u00b6 A theme can be created by creating a directory of the theme's name and then adding a manifest file in the theme's directory called theme.toml . Theme manifest \u00b6 The theme manifest contains a single dictionary key, theme . The following is a list of all of the respective keys and values for the manifest: theme - The root theme object name - The name of the theme. This should match the directory's name. type - The theme's color scheme type. Should either be \"light\" or \"dark\" resources-dir - The path to the theme's folder colors - The theme's text and interface colors background - The color to use for a background when an image isn't provided. interface - The color of the theme's foreground text interface_active - The theme's accent color interface_highlight - The theme's highlight color interface_secondary - The theme's \"muted\" or \"disabled\" color syntax - The theme's syntax colors source_text - The color for standard source text symbols - The color for code symbols comments - The color for code comments docstrings - The color for code documentation strings - The color for strings keywords - The color for keywords numbers - The color for constants such as numbers This is the manifest for ruby-light as an example: [theme] name = \"ruby-light\" type = \"light\" resources-dir = \"core/themes/ruby-light\" [theme.colors] background = \"#FAFAFA\" interface = \"#959DA6\" interface_active = \"#55B4D4\" interface_highlight = \"#77A8D9\" interface_secondary = \"#6C7680\" interface_button_idle = \"#FFCC66\" [theme.colors.syntax] source_text = \"#6C7680\" symbols = \"#6C7680\" comments = \"#ABB0B6\" docstrings = \"#ABB0B6\" strings = \"#86B300\" keywords = \"#FA8D3E\" numbers = \"#A37ACC\" Theme resources \u00b6 Interface elements such as frames, buttons, and checkboxes are drawn with image files, which are located in the resources directory of the theme's folder. The theme should contain files for the following elements: Bars Buttons Checkboxes Frames Overlays Radios Scrollers Sliders Tabs Most interact-able elements like checkboxes and buttons will have multiple states: idle , hover , selected_idle , selected_hover , and/or insensitive . Consult any of the default themes for the exact structure and kinds of files needed. Theme object \u00b6 The Theme object holds the data necessary to create and render a theme. The following is the Python documentation for this class. Constructor \u00b6 Construct a theme object. Args \u00b6 **kwargs: Arbitrary keyword arguments Kwargs \u00b6 filepath (str): The path to a valid theme configuration. name (str): The name of the theme. path (str): The path to the file's theme resources. colors() \u00b6 Get the theme's colors. Returns \u00b6 ui_colors (ThemeColor): The theme's UI colors. syntaxes() \u00b6 Get the theme's colors for syntax highlighting. Returns \u00b6 syntax_colors (ThemeSyntaxColor): The theme's syntax colors. checkboxes() \u00b6 Get the paths for the theme's checkbox styles. Returns \u00b6 checks (ThemeCheckbox): The theme's checkbox enumeration. radios() \u00b6 Get the paths for the theme's radio styles. Returns \u00b6 checks (ThemeRadio): The theme's radio enumeration. buttons() \u00b6 Get the path for the theme's button styles. Returns \u00b6 buttons (str): The path to the button images. tabs() \u00b6 Get the path for the theme's tab group styles. Returns \u00b6 tabs (str): The path to the tab group images. bars() \u00b6 Get the paths for the theme's bar styles. Returns \u00b6 bars (ThemeBars): The theme's bars enumeration. scrollbars() \u00b6 Get the paths for the theme's scrollbar styles. Returns \u00b6 scrollbars (ThemeScrollbars): The theme's scrollbars enumeration. sliders() \u00b6 Get the paths for the theme's slider styles. Returns \u00b6 sliders (ThemeSliders): The theme's scrollbars enumeration. frames() \u00b6 Get the paths for the theme's frame styles. Returns \u00b6 frames (ThemeFrame): The theme's frame enumeration. overlays() \u00b6 Get the paths for the theme's overlay styles. Returns \u00b6 overlays (overlay): The theme's overlay enumeration.","title":"Theming"},{"location":"core/themes/#theming","text":"Unscripted supports the creation and usage of themes which manage the overall look of the game and its interface. Themes are defined as a directory with a manifest and subdirectories of image files that contain the interface elements.","title":"Theming"},{"location":"core/themes/#default-themes","text":"There are four themes that ship with Unscripted: Ayu Light Blue ( ruby-light ) Ayu Mirage Blue ( ruby-mirage ) Ayu Dark Blue ( ruby-dark ) Ring ( ring ) All Ayu themes are variants of the Ayu color scheme with the accent color changed to the Unscripted blue color. Ring is the original Unscripted theme before the theme overhaul. The game will try to set ring as the default interface theme if no theme is present. In the game's settings under Appearance , the game will allow players to select from any of the Ayu themes.","title":"Default themes"},{"location":"core/themes/#creating-a-theme","text":"A theme can be created by creating a directory of the theme's name and then adding a manifest file in the theme's directory called theme.toml .","title":"Creating a theme"},{"location":"core/themes/#theme-manifest","text":"The theme manifest contains a single dictionary key, theme . The following is a list of all of the respective keys and values for the manifest: theme - The root theme object name - The name of the theme. This should match the directory's name. type - The theme's color scheme type. Should either be \"light\" or \"dark\" resources-dir - The path to the theme's folder colors - The theme's text and interface colors background - The color to use for a background when an image isn't provided. interface - The color of the theme's foreground text interface_active - The theme's accent color interface_highlight - The theme's highlight color interface_secondary - The theme's \"muted\" or \"disabled\" color syntax - The theme's syntax colors source_text - The color for standard source text symbols - The color for code symbols comments - The color for code comments docstrings - The color for code documentation strings - The color for strings keywords - The color for keywords numbers - The color for constants such as numbers This is the manifest for ruby-light as an example: [theme] name = \"ruby-light\" type = \"light\" resources-dir = \"core/themes/ruby-light\" [theme.colors] background = \"#FAFAFA\" interface = \"#959DA6\" interface_active = \"#55B4D4\" interface_highlight = \"#77A8D9\" interface_secondary = \"#6C7680\" interface_button_idle = \"#FFCC66\" [theme.colors.syntax] source_text = \"#6C7680\" symbols = \"#6C7680\" comments = \"#ABB0B6\" docstrings = \"#ABB0B6\" strings = \"#86B300\" keywords = \"#FA8D3E\" numbers = \"#A37ACC\"","title":"Theme manifest"},{"location":"core/themes/#theme-resources","text":"Interface elements such as frames, buttons, and checkboxes are drawn with image files, which are located in the resources directory of the theme's folder. The theme should contain files for the following elements: Bars Buttons Checkboxes Frames Overlays Radios Scrollers Sliders Tabs Most interact-able elements like checkboxes and buttons will have multiple states: idle , hover , selected_idle , selected_hover , and/or insensitive . Consult any of the default themes for the exact structure and kinds of files needed.","title":"Theme resources"},{"location":"core/themes/#theme-object","text":"The Theme object holds the data necessary to create and render a theme. The following is the Python documentation for this class.","title":"Theme object"},{"location":"core/themes/#constructor","text":"Construct a theme object.","title":"Constructor"},{"location":"core/themes/#args","text":"**kwargs: Arbitrary keyword arguments","title":"Args"},{"location":"core/themes/#kwargs","text":"filepath (str): The path to a valid theme configuration. name (str): The name of the theme. path (str): The path to the file's theme resources.","title":"Kwargs"},{"location":"core/themes/#colors","text":"Get the theme's colors.","title":"colors()"},{"location":"core/themes/#returns","text":"ui_colors (ThemeColor): The theme's UI colors.","title":"Returns"},{"location":"core/themes/#syntaxes","text":"Get the theme's colors for syntax highlighting.","title":"syntaxes()"},{"location":"core/themes/#returns_1","text":"syntax_colors (ThemeSyntaxColor): The theme's syntax colors.","title":"Returns"},{"location":"core/themes/#checkboxes","text":"Get the paths for the theme's checkbox styles.","title":"checkboxes()"},{"location":"core/themes/#returns_2","text":"checks (ThemeCheckbox): The theme's checkbox enumeration.","title":"Returns"},{"location":"core/themes/#radios","text":"Get the paths for the theme's radio styles.","title":"radios()"},{"location":"core/themes/#returns_3","text":"checks (ThemeRadio): The theme's radio enumeration.","title":"Returns"},{"location":"core/themes/#buttons","text":"Get the path for the theme's button styles.","title":"buttons()"},{"location":"core/themes/#returns_4","text":"buttons (str): The path to the button images.","title":"Returns"},{"location":"core/themes/#tabs","text":"Get the path for the theme's tab group styles.","title":"tabs()"},{"location":"core/themes/#returns_5","text":"tabs (str): The path to the tab group images.","title":"Returns"},{"location":"core/themes/#bars","text":"Get the paths for the theme's bar styles.","title":"bars()"},{"location":"core/themes/#returns_6","text":"bars (ThemeBars): The theme's bars enumeration.","title":"Returns"},{"location":"core/themes/#scrollbars","text":"Get the paths for the theme's scrollbar styles.","title":"scrollbars()"},{"location":"core/themes/#returns_7","text":"scrollbars (ThemeScrollbars): The theme's scrollbars enumeration.","title":"Returns"},{"location":"core/themes/#sliders","text":"Get the paths for the theme's slider styles.","title":"sliders()"},{"location":"core/themes/#returns_8","text":"sliders (ThemeSliders): The theme's scrollbars enumeration.","title":"Returns"},{"location":"core/themes/#frames","text":"Get the paths for the theme's frame styles.","title":"frames()"},{"location":"core/themes/#returns_9","text":"frames (ThemeFrame): The theme's frame enumeration.","title":"Returns"},{"location":"core/themes/#overlays","text":"Get the paths for the theme's overlay styles.","title":"overlays()"},{"location":"core/themes/#returns_10","text":"overlays (overlay): The theme's overlay enumeration.","title":"Returns"},{"location":"core/utilities/","text":"Common Utilities \u00b6 The following documentation is a running list of all of the common utilities in Unscripted Core. These utilities are found in src/logic/utils.rpy . InventoryMismatchError(Exception) \u00b6 The inventory between AliceOS and the player's doesn't match. FeatherAssetError(Exception) \u00b6 The Feather icon could not be found. TimeOfDay(Enum) \u00b6 An enumeration class for the different times of day (see dynamic backgrounds). Cases \u00b6 morning day night acquire_item(item_key) \u00b6 Add the item with a specific key to the inventory. Args \u00b6 item_key (str): The item's key. use_item(item_key, remove=False) \u00b6 Use the item with a given key. Args \u00b6 item_key (str): The item's key. remove (bool): Whether to remove the item from the inventory. Defaults to False. restore_inventory() \u00b6 Restore the inventory to the state listed in the player's inventory. grab_recent_items() \u00b6 Grab the five most recent items from the inventory. match_inventory_scheme(event, interact=True, **kwargs) \u00b6 Compare the current state's inventory and the AliceOS inventory and update AliceOS's inventory if there isn't a match. This is used in the character say callback to manage the state of the inventory to make sure that AliceOS's Inventories is keeping up with the player at a given point. Args \u00b6 event: The callback event interact (bool): Whether the dialogue causes an interaction update_item_callbacks(item_callbacks) \u00b6 Update the use case callbacks in the inventory. Args \u00b6 item_callbacks (dict): A dictionary containing the callbacks for items. clear_item_callbacks() \u00b6 Clear all of the existing callbacks for the inventory. get_feather_icon(name, mode=None) \u00b6 Get the path to a Feather icon. Args \u00b6 name (str): The name of the Feather icon. mode (Optional[str]): The mode to register the icon as (\"light\" or \"dark\"). Defaults to None. reset_playername() \u00b6 Reset the player to a default player with the name 'MC'. change_playing_state() \u00b6 Send an update to the Discord Rich Presence client and update the rich presence state. get_history_name(who) \u00b6 Get the history name of the character in question. Args \u00b6 who (str): The name of the character. finished_talks(a) \u00b6 Determine whether the given dictionary of talks has been completed. The dictionary is checked to see if all values are set to True. Args \u00b6 a (dict): The dictionary of talks. get_username() \u00b6 Get the username of the current computer user. escape_code(who, code=\"print \\\"Hello, world!\\\"\") \u00b6 Use a character line to speak code. Args \u00b6 who (Character): The character to deliver the dialogue code (str): The corresponding code. current_theme() \u00b6 Get the theme object for the currently selected theme. Returns \u00b6 theme (Theme): The theme object that corresponds to the GUI preference for the theme. If the theme object cannot be loaded, it will attempt to use the Ring theme. gtheme(name) \u00b6 Get the theme object for the currently selected theme. Returns \u00b6 theme (Theme): The theme object that corresponds to the GUI preference for the theme. If the theme object cannot be loaded, it will attempt to use the Ring theme. dynamic_background(image_path, include=[TimeOfDay.day, TimeOfDay.night]) \u00b6 Get the background based on the time of day, relative to \"Catalina City\" time. This utility assumes that Catalina City is occurring during the summer where the day is longer and the night is shorter. The utility reads the current hour on the user's machine and determines the appropriate image to apply. This utility also only works with JPEG files. Args \u00b6 image_path (str): The path to the image to use. include (list): A list of the different times of day to include in the dynamic background. Returns \u00b6 path (str): The path to the image according to the time of day. open_directory(path) \u00b6 Open the directory with the system's file browser. Args \u00b6 path (str): The path to open in the system's file browser.","title":"Common Utilities"},{"location":"core/utilities/#common-utilities","text":"The following documentation is a running list of all of the common utilities in Unscripted Core. These utilities are found in src/logic/utils.rpy .","title":"Common Utilities"},{"location":"core/utilities/#inventorymismatcherrorexception","text":"The inventory between AliceOS and the player's doesn't match.","title":"InventoryMismatchError(Exception)"},{"location":"core/utilities/#featherasseterrorexception","text":"The Feather icon could not be found.","title":"FeatherAssetError(Exception)"},{"location":"core/utilities/#timeofdayenum","text":"An enumeration class for the different times of day (see dynamic backgrounds).","title":"TimeOfDay(Enum)"},{"location":"core/utilities/#cases","text":"morning day night","title":"Cases"},{"location":"core/utilities/#acquire_itemitem_key","text":"Add the item with a specific key to the inventory.","title":"acquire_item(item_key)"},{"location":"core/utilities/#args","text":"item_key (str): The item's key.","title":"Args"},{"location":"core/utilities/#use_itemitem_key-removefalse","text":"Use the item with a given key.","title":"use_item(item_key, remove=False)"},{"location":"core/utilities/#args_1","text":"item_key (str): The item's key. remove (bool): Whether to remove the item from the inventory. Defaults to False.","title":"Args"},{"location":"core/utilities/#restore_inventory","text":"Restore the inventory to the state listed in the player's inventory.","title":"restore_inventory()"},{"location":"core/utilities/#grab_recent_items","text":"Grab the five most recent items from the inventory.","title":"grab_recent_items()"},{"location":"core/utilities/#match_inventory_schemeevent-interacttrue-kwargs","text":"Compare the current state's inventory and the AliceOS inventory and update AliceOS's inventory if there isn't a match. This is used in the character say callback to manage the state of the inventory to make sure that AliceOS's Inventories is keeping up with the player at a given point.","title":"match_inventory_scheme(event, interact=True, **kwargs)"},{"location":"core/utilities/#args_2","text":"event: The callback event interact (bool): Whether the dialogue causes an interaction","title":"Args"},{"location":"core/utilities/#update_item_callbacksitem_callbacks","text":"Update the use case callbacks in the inventory.","title":"update_item_callbacks(item_callbacks)"},{"location":"core/utilities/#args_3","text":"item_callbacks (dict): A dictionary containing the callbacks for items.","title":"Args"},{"location":"core/utilities/#clear_item_callbacks","text":"Clear all of the existing callbacks for the inventory.","title":"clear_item_callbacks()"},{"location":"core/utilities/#get_feather_iconname-modenone","text":"Get the path to a Feather icon.","title":"get_feather_icon(name, mode=None)"},{"location":"core/utilities/#args_4","text":"name (str): The name of the Feather icon. mode (Optional[str]): The mode to register the icon as (\"light\" or \"dark\"). Defaults to None.","title":"Args"},{"location":"core/utilities/#reset_playername","text":"Reset the player to a default player with the name 'MC'.","title":"reset_playername()"},{"location":"core/utilities/#change_playing_state","text":"Send an update to the Discord Rich Presence client and update the rich presence state.","title":"change_playing_state()"},{"location":"core/utilities/#get_history_namewho","text":"Get the history name of the character in question.","title":"get_history_name(who)"},{"location":"core/utilities/#args_5","text":"who (str): The name of the character.","title":"Args"},{"location":"core/utilities/#finished_talksa","text":"Determine whether the given dictionary of talks has been completed. The dictionary is checked to see if all values are set to True.","title":"finished_talks(a)"},{"location":"core/utilities/#args_6","text":"a (dict): The dictionary of talks.","title":"Args"},{"location":"core/utilities/#get_username","text":"Get the username of the current computer user.","title":"get_username()"},{"location":"core/utilities/#escape_codewho-codeprint-hello-world","text":"Use a character line to speak code.","title":"escape_code(who, code=\"print \\\"Hello, world!\\\"\")"},{"location":"core/utilities/#args_7","text":"who (Character): The character to deliver the dialogue code (str): The corresponding code.","title":"Args"},{"location":"core/utilities/#current_theme","text":"Get the theme object for the currently selected theme.","title":"current_theme()"},{"location":"core/utilities/#returns","text":"theme (Theme): The theme object that corresponds to the GUI preference for the theme. If the theme object cannot be loaded, it will attempt to use the Ring theme.","title":"Returns"},{"location":"core/utilities/#gthemename","text":"Get the theme object for the currently selected theme.","title":"gtheme(name)"},{"location":"core/utilities/#returns_1","text":"theme (Theme): The theme object that corresponds to the GUI preference for the theme. If the theme object cannot be loaded, it will attempt to use the Ring theme.","title":"Returns"},{"location":"core/utilities/#dynamic_backgroundimage_path-includetimeofdayday-timeofdaynight","text":"Get the background based on the time of day, relative to \"Catalina City\" time. This utility assumes that Catalina City is occurring during the summer where the day is longer and the night is shorter. The utility reads the current hour on the user's machine and determines the appropriate image to apply. This utility also only works with JPEG files.","title":"dynamic_background(image_path, include=[TimeOfDay.day, TimeOfDay.night])"},{"location":"core/utilities/#args_8","text":"image_path (str): The path to the image to use. include (list): A list of the different times of day to include in the dynamic background.","title":"Args"},{"location":"core/utilities/#returns_2","text":"path (str): The path to the image according to the time of day.","title":"Returns"},{"location":"core/utilities/#open_directorypath","text":"Open the directory with the system's file browser.","title":"open_directory(path)"},{"location":"core/utilities/#args_9","text":"path (str): The path to open in the system's file browser.","title":"Args"},{"location":"distribution/","text":"Ren'Py distributions made easier \u00b6 The Ren'Py Distribution Tools is a Python module that aims to make distribution of Ren'Py visual novel projects easier by automating it with Python utilities and classes. Getting Started \u00b6 Quick Start: Install via PyPI/Poetry \u00b6 To install via PyPI: pip install renpy-distribute-tools Or, if you're using a Poetry project, just add the dependency: poetry add renpy-distribute-tools What's included \u00b6 The Ren'Py Distribution Tools set comes with utilities that make it easy to do the following: Modifying a visual novel's Info.plist with an identifier and copyright field. Code-signing the visual novel binaries in the Mac app with entitlements. Creating a ZIP copy of the Mac app and sending it to Apple's notarization servers. Verifying the status of a notarization request. Stapling the notarization ticket to a macOS app. Publishing content to Itch.io.","title":"Home"},{"location":"distribution/#renpy-distributions-made-easier","text":"The Ren'Py Distribution Tools is a Python module that aims to make distribution of Ren'Py visual novel projects easier by automating it with Python utilities and classes.","title":"Ren'Py distributions made easier"},{"location":"distribution/#getting-started","text":"","title":"Getting Started"},{"location":"distribution/#quick-start-install-via-pypipoetry","text":"To install via PyPI: pip install renpy-distribute-tools Or, if you're using a Poetry project, just add the dependency: poetry add renpy-distribute-tools","title":"Quick Start: Install via PyPI/Poetry"},{"location":"distribution/#whats-included","text":"The Ren'Py Distribution Tools set comes with utilities that make it easy to do the following: Modifying a visual novel's Info.plist with an identifier and copyright field. Code-signing the visual novel binaries in the Mac app with entitlements. Creating a ZIP copy of the Mac app and sending it to Apple's notarization servers. Verifying the status of a notarization request. Stapling the notarization ticket to a macOS app. Publishing content to Itch.io.","title":"What's included"},{"location":"distribution/apple/","text":"apple \u00b6 The apple module contains important utilities to make signing, notarizing, and building packages for macOS easier. The functions in this module require a device running macOS with Xcode 10 or higher. darwin_only(call) \u00b6 A decorator for macOS-specific commands. This should be used to denote that a function only works on macOS due to reliance on built-in tools from macOS or Xcode. package_app_zip(app: str) \u00b6 Create a ZIP file of the app. Args: app (str): The path to the macOS to make an archive of build_pkg(app: str, identity: str, package_name: str) \u00b6 Create an installable package from a macOS app. By default, it will create an app package that installs to /Applications/ . This package installer can also be used to submit an app to the Mac App Store. If the package name isn't a file path, .pkg will automatically be appended at the end of the name. Args: app (str): The path to the app to create a package of. identity (str): The identity to sign the package with package_name (str): The name or path of the resulting package. code_sign(identity: str, app_directory: str, **kwargs) \u00b6 Digitally sign a macOS application with a signing identity and any entitlements. Args: identity (str): The identity to use during signing, usually a Developer ID. app_directory (str): The path to the macOS application for signing. **kwargs: Arbitrary keyword arguments. Kwargs: entitlements (str): (Optional) The path to the entitlements the app should be signed with. enable_hardened_runtime (bool): Whether to sign the app with the hardened runtime on. upload_to_notary(app: str, identifier: str, username: str, password: str, **kwargs) -> str \u00b6 Upload a macOS application archive to Apple's notary service for notarization. Args: app (str): The path to the macOS application to send to Apple. identifier (str): The bundle identifier of the application. username (str): The username (email address) of the Apple ID to notarize under. password (str): The password of the Apple ID to notarize under. **kwargs: Arbitrary keyword arguments. Kwargs: provider (str): The App Store Connect or iTunes Connect provider associated with the Apple ID used to sign the app. Returns: uuid_str (str): The request UUID. check_notary_status(uuid: str, username: str, password: str) -> int \u00b6 Get the notarization status of a given UUID. Arguments: uuid (str): The UUID of the app to check the status of. username (str): The user that submitted the notarization request. password (str): The password to use to sign into Apple. Returns: status (int): The status code associated with the UUID notarization request. A code of -1 indicates that getting the status code failed, either because the item could not be found or because no status code has been given yet. staple(app: str) \u00b6 Staple a notarization ticket to a notarized app. Args: app (str): The path of the macOS app to staple the ticket to.","title":"Apple"},{"location":"distribution/apple/#apple","text":"The apple module contains important utilities to make signing, notarizing, and building packages for macOS easier. The functions in this module require a device running macOS with Xcode 10 or higher.","title":"apple"},{"location":"distribution/apple/#darwin_onlycall","text":"A decorator for macOS-specific commands. This should be used to denote that a function only works on macOS due to reliance on built-in tools from macOS or Xcode.","title":"darwin_only(call)"},{"location":"distribution/apple/#package_app_zipapp-str","text":"Create a ZIP file of the app. Args: app (str): The path to the macOS to make an archive of","title":"package_app_zip(app: str)"},{"location":"distribution/apple/#build_pkgapp-str-identity-str-package_name-str","text":"Create an installable package from a macOS app. By default, it will create an app package that installs to /Applications/ . This package installer can also be used to submit an app to the Mac App Store. If the package name isn't a file path, .pkg will automatically be appended at the end of the name. Args: app (str): The path to the app to create a package of. identity (str): The identity to sign the package with package_name (str): The name or path of the resulting package.","title":"build_pkg(app: str, identity: str, package_name: str)"},{"location":"distribution/apple/#code_signidentity-str-app_directory-str-kwargs","text":"Digitally sign a macOS application with a signing identity and any entitlements. Args: identity (str): The identity to use during signing, usually a Developer ID. app_directory (str): The path to the macOS application for signing. **kwargs: Arbitrary keyword arguments. Kwargs: entitlements (str): (Optional) The path to the entitlements the app should be signed with. enable_hardened_runtime (bool): Whether to sign the app with the hardened runtime on.","title":"code_sign(identity: str, app_directory: str, **kwargs)"},{"location":"distribution/apple/#upload_to_notaryapp-str-identifier-str-username-str-password-str-kwargs-str","text":"Upload a macOS application archive to Apple's notary service for notarization. Args: app (str): The path to the macOS application to send to Apple. identifier (str): The bundle identifier of the application. username (str): The username (email address) of the Apple ID to notarize under. password (str): The password of the Apple ID to notarize under. **kwargs: Arbitrary keyword arguments. Kwargs: provider (str): The App Store Connect or iTunes Connect provider associated with the Apple ID used to sign the app. Returns: uuid_str (str): The request UUID.","title":"upload_to_notary(app: str, identifier: str, username: str, password: str, **kwargs) -&gt; str"},{"location":"distribution/apple/#check_notary_statusuuid-str-username-str-password-str-int","text":"Get the notarization status of a given UUID. Arguments: uuid (str): The UUID of the app to check the status of. username (str): The user that submitted the notarization request. password (str): The password to use to sign into Apple. Returns: status (int): The status code associated with the UUID notarization request. A code of -1 indicates that getting the status code failed, either because the item could not be found or because no status code has been given yet.","title":"check_notary_status(uuid: str, username: str, password: str) -&gt; int"},{"location":"distribution/apple/#stapleapp-str","text":"Staple a notarization ticket to a notarized app. Args: app (str): The path of the macOS app to staple the ticket to.","title":"staple(app: str)"},{"location":"distribution/fixed_zipfile/","text":"fixed_zipfile \u00b6 ZipFile \u00b6 The ZipFile class is a patched version of the ZipFile class in the zipfile module that retains the attribute permissions for files. Methods \u00b6 extract(self, member, path=None, pwd=None) \u00b6 extractall(self, path=None, members=None, pwd=None) \u00b6 MyZipFile \u00b6 The MyZipFile class is a patched version of the ZipFile class in the zipfile module that retains the attribute permissions for files. Warning MyZipFile has been renamed to ZipFile.","title":"Fixed ZipFile"},{"location":"distribution/fixed_zipfile/#fixed_zipfile","text":"","title":"fixed_zipfile"},{"location":"distribution/fixed_zipfile/#zipfile","text":"The ZipFile class is a patched version of the ZipFile class in the zipfile module that retains the attribute permissions for files.","title":"ZipFile"},{"location":"distribution/fixed_zipfile/#methods","text":"","title":"Methods"},{"location":"distribution/fixed_zipfile/#extractself-member-pathnone-pwdnone","text":"","title":"extract(self, member, path=None, pwd=None)"},{"location":"distribution/fixed_zipfile/#extractallself-pathnone-membersnone-pwdnone","text":"","title":"extractall(self, path=None, members=None, pwd=None)"},{"location":"distribution/fixed_zipfile/#myzipfile","text":"The MyZipFile class is a patched version of the ZipFile class in the zipfile module that retains the attribute permissions for files. Warning MyZipFile has been renamed to ZipFile.","title":"MyZipFile"},{"location":"distribution/itch/","text":"itch \u00b6 The itch module contains the code necessary to push projects to Itch.io using the butler tool. ButlerPlatformType(Enum) \u00b6 Enumerations for platform types. Butler \u00b6 The handler for publishing content to Itch.io using Butler. Attributes \u00b6 author (str): The itch.io username that is publishing content. project (str): The project that the author is publishing content for. bin (str): The path to the Butler executable. tag_rules (dict): A dictionary containing rules for additional tags. Methods \u00b6 __init__(self, author, project, **kwargs) \u00b6 Initialize a Butler class. Arguments: author (str): The itch.io user that will submit a project. project (str): The project that the user will submit. Kwargs: exec (str): The path to the Butler executable file. Defaults to \"butler\". push(self, file: str, **kwargs) \u00b6 Push the file to the Itch.io page. Arguments: file (str): The path to the file to push. **kwargs: Arbitrary keyword arguments Kwargs: user_version (str): The user version to use, if any. with_tag_rule (str): The tag rule to use. This is used as a channel. with_custom_tag (str): The tag to use at the end of the tag rule name. add_tag_rule(self, name: str, platform: ButlerPlatformType) \u00b6 Create a new rule for the project's channel tags. Arguments: name (str): The rule that will determine what platform to store it under. platform (ButlerPlatformType): The platform for that rule.","title":"Itch"},{"location":"distribution/itch/#itch","text":"The itch module contains the code necessary to push projects to Itch.io using the butler tool.","title":"itch"},{"location":"distribution/itch/#butlerplatformtypeenum","text":"Enumerations for platform types.","title":"ButlerPlatformType(Enum)"},{"location":"distribution/itch/#butler","text":"The handler for publishing content to Itch.io using Butler.","title":"Butler"},{"location":"distribution/itch/#attributes","text":"author (str): The itch.io username that is publishing content. project (str): The project that the author is publishing content for. bin (str): The path to the Butler executable. tag_rules (dict): A dictionary containing rules for additional tags.","title":"Attributes"},{"location":"distribution/itch/#methods","text":"","title":"Methods"},{"location":"distribution/itch/#__init__self-author-project-kwargs","text":"Initialize a Butler class. Arguments: author (str): The itch.io user that will submit a project. project (str): The project that the user will submit. Kwargs: exec (str): The path to the Butler executable file. Defaults to \"butler\".","title":"__init__(self, author, project, **kwargs)"},{"location":"distribution/itch/#pushself-file-str-kwargs","text":"Push the file to the Itch.io page. Arguments: file (str): The path to the file to push. **kwargs: Arbitrary keyword arguments Kwargs: user_version (str): The user version to use, if any. with_tag_rule (str): The tag rule to use. This is used as a channel. with_custom_tag (str): The tag to use at the end of the tag rule name.","title":"push(self, file: str, **kwargs)"},{"location":"distribution/itch/#add_tag_ruleself-name-str-platform-butlerplatformtype","text":"Create a new rule for the project's channel tags. Arguments: name (str): The rule that will determine what platform to store it under. platform (ButlerPlatformType): The platform for that rule.","title":"add_tag_rule(self, name: str, platform: ButlerPlatformType)"},{"location":"distribution/plist/","text":"plist \u00b6 This module contains some utilities that help fix the property lists in the macOS versions of a Ren'Py project. fix_plist(plist_file: str, identifier: str, p_copyright: str) \u00b6 Add the bundle identifier and copyright text to a Ren'Py-built macOS app's Info.plist. Args: plist_file (str): The path to the plist file to modify identifier (str): The bundle identifier to set the app to p_copyright (str): The human-readable copyright text to attach","title":"Property Lists"},{"location":"distribution/plist/#plist","text":"This module contains some utilities that help fix the property lists in the macOS versions of a Ren'Py project.","title":"plist"},{"location":"distribution/plist/#fix_plistplist_file-str-identifier-str-p_copyright-str","text":"Add the bundle identifier and copyright text to a Ren'Py-built macOS app's Info.plist. Args: plist_file (str): The path to the plist file to modify identifier (str): The bundle identifier to set the app to p_copyright (str): The human-readable copyright text to attach","title":"fix_plist(plist_file: str, identifier: str, p_copyright: str)"},{"location":"distribution/util/","text":"util \u00b6 This module contains some basic utilities to locate Ren'Py distributables and to find the macOS version of a VN. deprecated(message: str = \"\") \u00b6 Mark a function as deprecated. This is used as a decorator to mark some functions as deprecated without needing to import warnings repeatedly. The function that uses the decorator will be called but will display a deprecation warning with a supplied message. Arguments: message (str): The message or reason for deprecation. Defaults to a generic statement generated by the function's name. Returns: warnable (Callable): The function with a warning wrapper. file_exists(directory: str = os.getcwd(), item: str = '') -> Optional[str] \u00b6 Determine whether a file exists in a certain directory. Warning This function is being deprecated in favor of the utilities provided in the os module. Args: dir (str): The directory to search in. item (str): The item to search for in the directory. Returns: fname (str): File name if it's found or None if it doesn't find anything verify_built_files(directory: str = os.getcwd()) -> Optional[str] \u00b6 Determine if the Ren'Py distributions have been built already by looking for the -dists directory. This function will check if the directory exists in itself. Warning This function is no longer supported. Args: - dir (str): The directory to search. Returns: - isdir (bool): Whether the directory exists or not. find_mac_build(directory: str) -> bool \u00b6 Determine whether the macOS builds have been created. Warning This function is no longer supported. Args: - dir (str): The directory to search in Returns: - isfile (bool): Whether the macOS ZIP file exists.","title":"Utilities"},{"location":"distribution/util/#util","text":"This module contains some basic utilities to locate Ren'Py distributables and to find the macOS version of a VN.","title":"util"},{"location":"distribution/util/#deprecatedmessage-str","text":"Mark a function as deprecated. This is used as a decorator to mark some functions as deprecated without needing to import warnings repeatedly. The function that uses the decorator will be called but will display a deprecation warning with a supplied message. Arguments: message (str): The message or reason for deprecation. Defaults to a generic statement generated by the function's name. Returns: warnable (Callable): The function with a warning wrapper.","title":"deprecated(message: str = \"\")"},{"location":"distribution/util/#file_existsdirectory-str-osgetcwd-item-str-optionalstr","text":"Determine whether a file exists in a certain directory. Warning This function is being deprecated in favor of the utilities provided in the os module. Args: dir (str): The directory to search in. item (str): The item to search for in the directory. Returns: fname (str): File name if it's found or None if it doesn't find anything","title":"file_exists(directory: str = os.getcwd(), item: str = '') -&gt; Optional[str]"},{"location":"distribution/util/#verify_built_filesdirectory-str-osgetcwd-optionalstr","text":"Determine if the Ren'Py distributions have been built already by looking for the -dists directory. This function will check if the directory exists in itself. Warning This function is no longer supported. Args: - dir (str): The directory to search. Returns: - isdir (bool): Whether the directory exists or not.","title":"verify_built_files(directory: str = os.getcwd()) -&gt; Optional[str]"},{"location":"distribution/util/#find_mac_builddirectory-str-bool","text":"Determine whether the macOS builds have been created. Warning This function is no longer supported. Args: - dir (str): The directory to search in Returns: - isfile (bool): Whether the macOS ZIP file exists.","title":"find_mac_build(directory: str) -&gt; bool"},{"location":"fira/","text":"The minigame backend for Unscripted \u00b6 Fira is the main backend and API code for the minigame in Unscripted , a visual novel about software development. Fira provides many facets of the minigame, including a public API that players can use to code solutions to the minigame puzzles, a configuration and data generator from level files, and a virtual machine that runs low-level code that the minigame processes. Not Available Yet The Advanced Mode APIs for the minigame are currently not available in the release candidates of Unscripted. They will be made available in a future update. Getting started \u00b6 Fira comes pre-packaged in Unscripted but can be installed outside of the game to work better with IDEs and other Python tools such as Poetry. Dependencies \u00b6 Fira is both a Python 2 and Python 3 package and relies on the TOML Python package. These dependencies will be installed with the package, either from source or from PyPI. Quick Start: Install on PyPI \u00b6 Fira is available on PyPI and can be installed as such: pip install uvn-fira Install from source \u00b6 To install Fira from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry . In the root of the source, run the following commands: poetry install poetry build The resulting wheel files will be available in the dist directory.","title":"Home"},{"location":"fira/#the-minigame-backend-for-unscripted","text":"Fira is the main backend and API code for the minigame in Unscripted , a visual novel about software development. Fira provides many facets of the minigame, including a public API that players can use to code solutions to the minigame puzzles, a configuration and data generator from level files, and a virtual machine that runs low-level code that the minigame processes. Not Available Yet The Advanced Mode APIs for the minigame are currently not available in the release candidates of Unscripted. They will be made available in a future update.","title":"The minigame backend for Unscripted"},{"location":"fira/#getting-started","text":"Fira comes pre-packaged in Unscripted but can be installed outside of the game to work better with IDEs and other Python tools such as Poetry.","title":"Getting started"},{"location":"fira/#dependencies","text":"Fira is both a Python 2 and Python 3 package and relies on the TOML Python package. These dependencies will be installed with the package, either from source or from PyPI.","title":"Dependencies"},{"location":"fira/#quick-start-install-on-pypi","text":"Fira is available on PyPI and can be installed as such: pip install uvn-fira","title":"Quick Start: Install on PyPI"},{"location":"fira/#install-from-source","text":"To install Fira from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry . In the root of the source, run the following commands: poetry install poetry build The resulting wheel files will be available in the dist directory.","title":"Install from source"},{"location":"fira/gameplay/","text":"Gameplay \u00b6 In the Unscripted minigame, players play as Mia, an employee at a tech startup company, as she investigates what happened to everyone while powering on various computers around the office. Players need to make use of NadiaVM commands and exploit intentional \"bugs\" to solve various puzzles while avoiding obstacles. Gameplay Modes \u00b6 There are two game modes that the minigame offers: Basic mode , where players interactively type a series of NadiaVM commands to solve puzzles Advanced mode , where players write Python scripts and/or NadiaVM files to solve puzzles Basic Mode \u00b6 In the basic mode, players get an interactive NadiaVM console with a cheat sheet to control Mia. A compass is provided at the top to provide directions, and the console supports using the up arrow key to auto-fill in the previous command. Output for this virtual machine can appear in the game's logs for debugging purposes. The console accepts all valid NadiaVM commands and will execute them accordingly, such as set , alloc , and bind . Limitations There are also some limitations of basic mode in the minigame: When the player moves, they do not automatically turn on nearby computers, meaning that players will need to explicitly tell Mia to turn the computer on. However, the player does not need to tell Mia to exit the level. The console cannot run any pre-compiled files. All commands must be entered manually. Errors are not displayed in the console. Commands cannot be chained. Advanced Mode \u00b6 In the advanced mode, players are offered the ability to solve puzzles programmatically using Python or another language that can compile NadiaVM files. The Fira package offers an official API that can be used to write the necessary code. Players do not see a VM input view or any buttons for inputting commands, but rather see the world preview. By default, the advanced mode is disabled; it can be enabled in Settings \u203a Minigame by ticking \"Enable advanced mode\". Limitations There are also some limitations to the official API when using Advanced Mode: When using get_level_information to write code, [layers should not use the player variable. This conflicts with the game's own player variable. When using get_level_information , the Python script must end with the exit command if using the official Fira API. The player's exit command is also responsible for writing the virtual machine file. Some aspects of the minigame may work unexpectedly when using get_level_information . The API has been designed with some safety checks but is not a safeguard against Python's quirks.","title":"Gameplay"},{"location":"fira/gameplay/#gameplay","text":"In the Unscripted minigame, players play as Mia, an employee at a tech startup company, as she investigates what happened to everyone while powering on various computers around the office. Players need to make use of NadiaVM commands and exploit intentional \"bugs\" to solve various puzzles while avoiding obstacles.","title":"Gameplay"},{"location":"fira/gameplay/#gameplay-modes","text":"There are two game modes that the minigame offers: Basic mode , where players interactively type a series of NadiaVM commands to solve puzzles Advanced mode , where players write Python scripts and/or NadiaVM files to solve puzzles","title":"Gameplay Modes"},{"location":"fira/gameplay/#basic-mode","text":"In the basic mode, players get an interactive NadiaVM console with a cheat sheet to control Mia. A compass is provided at the top to provide directions, and the console supports using the up arrow key to auto-fill in the previous command. Output for this virtual machine can appear in the game's logs for debugging purposes. The console accepts all valid NadiaVM commands and will execute them accordingly, such as set , alloc , and bind . Limitations There are also some limitations of basic mode in the minigame: When the player moves, they do not automatically turn on nearby computers, meaning that players will need to explicitly tell Mia to turn the computer on. However, the player does not need to tell Mia to exit the level. The console cannot run any pre-compiled files. All commands must be entered manually. Errors are not displayed in the console. Commands cannot be chained.","title":"Basic Mode"},{"location":"fira/gameplay/#advanced-mode","text":"In the advanced mode, players are offered the ability to solve puzzles programmatically using Python or another language that can compile NadiaVM files. The Fira package offers an official API that can be used to write the necessary code. Players do not see a VM input view or any buttons for inputting commands, but rather see the world preview. By default, the advanced mode is disabled; it can be enabled in Settings \u203a Minigame by ticking \"Enable advanced mode\". Limitations There are also some limitations to the official API when using Advanced Mode: When using get_level_information to write code, [layers should not use the player variable. This conflicts with the game's own player variable. When using get_level_information , the Python script must end with the exit command if using the official Fira API. The player's exit command is also responsible for writing the virtual machine file. Some aspects of the minigame may work unexpectedly when using get_level_information . The API has been designed with some safety checks but is not a safeguard against Python's quirks.","title":"Advanced Mode"},{"location":"fira/implementation/","text":"Implementation \u00b6 How the minigame works \u00b6 In the minigame, players are tasked to create a set of commands that will be executed by a virtual machine in the preview scene in hopes of powering on all computers and reaching the exit. Although the method of getting the commands varies, the minigame will attempt to read from a virtual machine file and execute its commands as necessary. Obtaining code for basic and advanced modes \u00b6 In the case of the two game modes in Unscripted, both modes make use of Fira's core module to generate virtual machine code. In either mode, memory management and pushing/popping from memory is automatically managed and written for the player. Basic Mode \u00b6 In the basic mode, the player works inside of a NadiaVM interpreter, which will parse and execute commands sent to it. This is achieved by creating an interactive CSNadiaVM . Advanced Mode \u00b6 In the advanced mode with the Fira API module, players get direct low-level access to the NadiaVM writer via the MinigameLevel class, which returns the writer in addition to level data. When running close on this class, the file is compiled and written for the previewer to read. MinigameLevel also supports context management with the with keyword in Python, automatically taking care of file operations for the player. Via get_level_information \u00b6 For the advanced mode via the Fira API module, the APIs link to a hidden VM writer ( CSNadiaVMWriter ) that gets invoked when the player calls functions in the API. The exit method of the CSPlayer class is responsible for writing the VM file, hence why Python scripts must invoke this function. When the player is finished writing the script and clicks \"Run\", the Python compiler compiles and executes the script inside of Ren'Py's Python environment, generating the VM file in the process in the save directory of the game that will be read by the preview scene. Obtaining code from third-party tools \u00b6 Third-party tools will most likely create an abstraction layer in a similar fashion to the Fira API module. These tools will eventually create the VM file that the preview scene will read. Implementation of the VM varies depending on the tool, so it is recommended that you read the documentation of the respective tool or library on how it writes VM files. Players may also choose to write their own VM files directly, though this is not generally recommended. Preview scene execution (Advanced mode only) \u00b6 Once the VM file is written, the data is sent to a virtual machine emulator ( CSNadiaVM ), which is later sent to the preview scene. Once the preview scene renders the world and components, the preview scene will call on the VM emulator to execute the commands in order. For commands that require animation (i.e., move and collect ), execution pauses as the preview scene presents the corresponding animation. NadiaVM \u00b6 Fira contains the virtual machine used in processing and managing the preview scene, NadiaVM. NadiaVM is a simple, stack-based virtual machine with a couple of commands. The VM is designed to focus specifically on the minigame's internal game logic and is not necessarily suitable for general use. NadiaVM files are registered with the file extension .nvm and are typically plain text files with the corresponding instructions. Commands \u00b6 NadiaVM comes with several commands used to perform tasks in the minigame: alloc (str) (int) : Create a new array with a name and a specific size. collect : Collect a coin in the world. Acts like a pause in VM. push (str) (int) : Push the top of the stack to the given array at the index. pop (str) (int) : Pop the item located at the array's index and move it to the top of the stack. set (constant|casted_value) (any) : Set the top of the stack to a constant value. move player (str) : Move the player in a given direction. exit player : Try to end the execution script and finish the level. add : Add the two topmost values on the stack. sub : Subtract the two topmost values on the stack. mult : Multiply the two topmost values on the stack. div : Divide the two topmost values on the stack. neg : Negate the topmost value on the stack. Effectively the same as pushing -1 on the stack and calling mult . bind (str) (command) : Bind a given command to a name. cast (str) (any) : Cast the value to a given name, similar to variable assignment. Limitations \u00b6 NadiaVM is a simple stack-based virtual machine designed to process commands quickly, meaning that there are limitations to how it works: NadiaVM files can't reference each other. NadiaVM doesn't support control flow or functions. NadiaVM doesn't work with pointers or deal with memory addresses; rather, it works with creating its own lists and modifying them accordingly.","title":"Implementation"},{"location":"fira/implementation/#implementation","text":"","title":"Implementation"},{"location":"fira/implementation/#how-the-minigame-works","text":"In the minigame, players are tasked to create a set of commands that will be executed by a virtual machine in the preview scene in hopes of powering on all computers and reaching the exit. Although the method of getting the commands varies, the minigame will attempt to read from a virtual machine file and execute its commands as necessary.","title":"How the minigame works"},{"location":"fira/implementation/#obtaining-code-for-basic-and-advanced-modes","text":"In the case of the two game modes in Unscripted, both modes make use of Fira's core module to generate virtual machine code. In either mode, memory management and pushing/popping from memory is automatically managed and written for the player.","title":"Obtaining code for basic and advanced modes"},{"location":"fira/implementation/#basic-mode","text":"In the basic mode, the player works inside of a NadiaVM interpreter, which will parse and execute commands sent to it. This is achieved by creating an interactive CSNadiaVM .","title":"Basic Mode"},{"location":"fira/implementation/#advanced-mode","text":"In the advanced mode with the Fira API module, players get direct low-level access to the NadiaVM writer via the MinigameLevel class, which returns the writer in addition to level data. When running close on this class, the file is compiled and written for the previewer to read. MinigameLevel also supports context management with the with keyword in Python, automatically taking care of file operations for the player.","title":"Advanced Mode"},{"location":"fira/implementation/#via-get_level_information","text":"For the advanced mode via the Fira API module, the APIs link to a hidden VM writer ( CSNadiaVMWriter ) that gets invoked when the player calls functions in the API. The exit method of the CSPlayer class is responsible for writing the VM file, hence why Python scripts must invoke this function. When the player is finished writing the script and clicks \"Run\", the Python compiler compiles and executes the script inside of Ren'Py's Python environment, generating the VM file in the process in the save directory of the game that will be read by the preview scene.","title":"Via get_level_information"},{"location":"fira/implementation/#obtaining-code-from-third-party-tools","text":"Third-party tools will most likely create an abstraction layer in a similar fashion to the Fira API module. These tools will eventually create the VM file that the preview scene will read. Implementation of the VM varies depending on the tool, so it is recommended that you read the documentation of the respective tool or library on how it writes VM files. Players may also choose to write their own VM files directly, though this is not generally recommended.","title":"Obtaining code from third-party tools"},{"location":"fira/implementation/#preview-scene-execution-advanced-mode-only","text":"Once the VM file is written, the data is sent to a virtual machine emulator ( CSNadiaVM ), which is later sent to the preview scene. Once the preview scene renders the world and components, the preview scene will call on the VM emulator to execute the commands in order. For commands that require animation (i.e., move and collect ), execution pauses as the preview scene presents the corresponding animation.","title":"Preview scene execution (Advanced mode only)"},{"location":"fira/implementation/#nadiavm","text":"Fira contains the virtual machine used in processing and managing the preview scene, NadiaVM. NadiaVM is a simple, stack-based virtual machine with a couple of commands. The VM is designed to focus specifically on the minigame's internal game logic and is not necessarily suitable for general use. NadiaVM files are registered with the file extension .nvm and are typically plain text files with the corresponding instructions.","title":"NadiaVM"},{"location":"fira/implementation/#commands","text":"NadiaVM comes with several commands used to perform tasks in the minigame: alloc (str) (int) : Create a new array with a name and a specific size. collect : Collect a coin in the world. Acts like a pause in VM. push (str) (int) : Push the top of the stack to the given array at the index. pop (str) (int) : Pop the item located at the array's index and move it to the top of the stack. set (constant|casted_value) (any) : Set the top of the stack to a constant value. move player (str) : Move the player in a given direction. exit player : Try to end the execution script and finish the level. add : Add the two topmost values on the stack. sub : Subtract the two topmost values on the stack. mult : Multiply the two topmost values on the stack. div : Divide the two topmost values on the stack. neg : Negate the topmost value on the stack. Effectively the same as pushing -1 on the stack and calling mult . bind (str) (command) : Bind a given command to a name. cast (str) (any) : Cast the value to a given name, similar to variable assignment.","title":"Commands"},{"location":"fira/implementation/#limitations","text":"NadiaVM is a simple stack-based virtual machine designed to process commands quickly, meaning that there are limitations to how it works: NadiaVM files can't reference each other. NadiaVM doesn't support control flow or functions. NadiaVM doesn't work with pointers or deal with memory addresses; rather, it works with creating its own lists and modifying them accordingly.","title":"Limitations"},{"location":"fira/levels/","text":"Level Structure \u00b6 The minigame's level files are a series of markup files using TOML that describe the information about that level, as well as the overall layout of the level's world. Level files have a root key level with two subkeys, map and config . Configuration Fields \u00b6 There are a few primary fields in the config entry of the TOML file: name : The name of the level check : A list of strings containing the requirements for completing the level bugs : (Optional) The list of \"intentional bugs\" to enable in this level allowed-blocks : A list of strings containing the allowed blocks that appear in the basic mode editor Warning allowed_blocks is deprecated and should not be used in future level configurations. Checks \u00b6 player-at-exit : Whether or not the player has reached the exit player-collects-all : Whether or not the player has collected all of the coins Allowed blocks \u00b6 move : Directional movement blocks collect : Collect coin clock exit : Exit level block Bugs \u00b6 missing-poweron-bind : The binding for poweron to collect is missing collision-checks-fail : Collisions between walls or other objects is disabled exit-changes-randomly : The location for the exit randomly changes Map Construction \u00b6 The map subkey contains a single value layout that contains a multiline string that describes the world using ASCII characters. An example is provided below: %%%%%%% %P . E% %%%%%%% Map Symbols \u00b6 There are five acceptable characters to use when creating the layout string: % : A wall P : The player's starting position . : A desk with a turned off computer E : The exit block to stand on : An air block or null space X : Void space Limitations \u00b6 There are a few limitations regarding the world map string: There cannot be more than one player or exit in a map. Each line must have the same number of characters to keep a consistent size. Example level configuration \u00b6 [level.config] name = \"Example\" allowed-blocks = [\"move\", \"exit\"] check = [\"player-at-exit\"] [level.map] layout = \"\"\" %%%%% %%%%% % P% %E % % %%% %%% % % %%% %%% % % % %%%%%%%%%%% \"\"\"","title":"Levels"},{"location":"fira/levels/#level-structure","text":"The minigame's level files are a series of markup files using TOML that describe the information about that level, as well as the overall layout of the level's world. Level files have a root key level with two subkeys, map and config .","title":"Level Structure"},{"location":"fira/levels/#configuration-fields","text":"There are a few primary fields in the config entry of the TOML file: name : The name of the level check : A list of strings containing the requirements for completing the level bugs : (Optional) The list of \"intentional bugs\" to enable in this level allowed-blocks : A list of strings containing the allowed blocks that appear in the basic mode editor Warning allowed_blocks is deprecated and should not be used in future level configurations.","title":"Configuration Fields"},{"location":"fira/levels/#checks","text":"player-at-exit : Whether or not the player has reached the exit player-collects-all : Whether or not the player has collected all of the coins","title":"Checks"},{"location":"fira/levels/#allowed-blocks","text":"move : Directional movement blocks collect : Collect coin clock exit : Exit level block","title":"Allowed blocks"},{"location":"fira/levels/#bugs","text":"missing-poweron-bind : The binding for poweron to collect is missing collision-checks-fail : Collisions between walls or other objects is disabled exit-changes-randomly : The location for the exit randomly changes","title":"Bugs"},{"location":"fira/levels/#map-construction","text":"The map subkey contains a single value layout that contains a multiline string that describes the world using ASCII characters. An example is provided below: %%%%%%% %P . E% %%%%%%%","title":"Map Construction"},{"location":"fira/levels/#map-symbols","text":"There are five acceptable characters to use when creating the layout string: % : A wall P : The player's starting position . : A desk with a turned off computer E : The exit block to stand on : An air block or null space X : Void space","title":"Map Symbols"},{"location":"fira/levels/#limitations","text":"There are a few limitations regarding the world map string: There cannot be more than one player or exit in a map. Each line must have the same number of characters to keep a consistent size.","title":"Limitations"},{"location":"fira/levels/#example-level-configuration","text":"[level.config] name = \"Example\" allowed-blocks = [\"move\", \"exit\"] check = [\"player-at-exit\"] [level.map] layout = \"\"\" %%%%% %%%%% % P% %E % % %%% %%% % % %%% %%% % % % %%%%%%%%%%% \"\"\"","title":"Example level configuration"},{"location":"fira/api/","text":"Fira API \u00b6 The api module contains all of the player-facing functions and classes used in the Advanced Mode of the Unscripted minigame. The Unscriped Minigame Application Programming Interface (API) allows players to directly manipulate the player's movements and actions while traversing in the minigame world using Python. The minigame's logic will handle translating any commands to display at the end of the script compilation. Accessibility Warning Although most (if not all) of the submodules in the parent package are publicly accessible, it is heavily encouraged that players make use of the standard utilities provided with the API module. The documentation for some components in the core submodule are provided for reference namely, grid.CSWorldGrid and vm.CSMinigameWriter . Contents \u00b6 The api module comes with a few submodules that contain function and utilities for multiple aspects of the minigame: player hosts all of the code related to manipulating the player in the minigame. world hosts all of the code related to viewing and gathering information about the world in the minigame. grid hosts a publicly available version of the internal grid system used for world generation. info hosts all of the utilities to start writing code for levels. Migrating from v1.x \u00b6 The Fira API v2.x series is not exactly backwards-compatible with previous Fira API versions, nor is it backwards-compatible with older NadiaVM language files. The following sections provides tips for how to migrate code from the old Fira API version to newer versions. Namely, this will affect players that are migrating from the Unscripted Demo or older development builds of the game. Using player.CSPlayer \u00b6 The following methods are no longer available when using the player.CSPlayer object. It is recommended to change your code to use the new methods outlined. CSPlayer.exit : Use player.CSPlayer.finish instead. CSPlayer.collect : Use player.CSPlayer.toggle instead. Using world.CSWorld \u00b6 The following methods and properties are no longer available when using the world.CSWorld object. It is recommended to change your code to use the new methods and properties outlined. CSWorld.coins : Use world.CSWorld.devices instead. Using info.get_level_information \u00b6 In older Fira API versions, info.get_level_information was the function used to get information about a world, the player, and to write code for the player to follow. This method can sometimes cause unexpected results with Python's native features and could potentially produce broken virutal machine code. A new class, info.MinigameLevel , attempts to resolve this issue. The class provides direct access to the virtual machine writers and allows players to write virtual machine code in a clean, elegant way without the abstraction overhead from other methods. info.MinigameLevel provides support for the with keyword and context manager in Python, allowing for clean and concise code. with MinigameLevel(1) as vm, data: devices = data.devices().as_list() vm.alloc(\"world_coins\", len(devices)) vm.alloc(\"inventory\", len(devices)) for device in devices: vm.set(device) vm.push(\"world_coins\", devices.index(device))","title":"API"},{"location":"fira/api/#fira-api","text":"The api module contains all of the player-facing functions and classes used in the Advanced Mode of the Unscripted minigame. The Unscriped Minigame Application Programming Interface (API) allows players to directly manipulate the player's movements and actions while traversing in the minigame world using Python. The minigame's logic will handle translating any commands to display at the end of the script compilation. Accessibility Warning Although most (if not all) of the submodules in the parent package are publicly accessible, it is heavily encouraged that players make use of the standard utilities provided with the API module. The documentation for some components in the core submodule are provided for reference namely, grid.CSWorldGrid and vm.CSMinigameWriter .","title":"Fira API"},{"location":"fira/api/#contents","text":"The api module comes with a few submodules that contain function and utilities for multiple aspects of the minigame: player hosts all of the code related to manipulating the player in the minigame. world hosts all of the code related to viewing and gathering information about the world in the minigame. grid hosts a publicly available version of the internal grid system used for world generation. info hosts all of the utilities to start writing code for levels.","title":"Contents"},{"location":"fira/api/#migrating-from-v1x","text":"The Fira API v2.x series is not exactly backwards-compatible with previous Fira API versions, nor is it backwards-compatible with older NadiaVM language files. The following sections provides tips for how to migrate code from the old Fira API version to newer versions. Namely, this will affect players that are migrating from the Unscripted Demo or older development builds of the game.","title":"Migrating from v1.x"},{"location":"fira/api/#using-playercsplayer","text":"The following methods are no longer available when using the player.CSPlayer object. It is recommended to change your code to use the new methods outlined. CSPlayer.exit : Use player.CSPlayer.finish instead. CSPlayer.collect : Use player.CSPlayer.toggle instead.","title":"Using player.CSPlayer"},{"location":"fira/api/#using-worldcsworld","text":"The following methods and properties are no longer available when using the world.CSWorld object. It is recommended to change your code to use the new methods and properties outlined. CSWorld.coins : Use world.CSWorld.devices instead.","title":"Using world.CSWorld"},{"location":"fira/api/#using-infoget_level_information","text":"In older Fira API versions, info.get_level_information was the function used to get information about a world, the player, and to write code for the player to follow. This method can sometimes cause unexpected results with Python's native features and could potentially produce broken virutal machine code. A new class, info.MinigameLevel , attempts to resolve this issue. The class provides direct access to the virtual machine writers and allows players to write virtual machine code in a clean, elegant way without the abstraction overhead from other methods. info.MinigameLevel provides support for the with keyword and context manager in Python, allowing for clean and concise code. with MinigameLevel(1) as vm, data: devices = data.devices().as_list() vm.alloc(\"world_coins\", len(devices)) vm.alloc(\"inventory\", len(devices)) for device in devices: vm.set(device) vm.push(\"world_coins\", devices.index(device))","title":"Using info.get_level_information"},{"location":"fira/api/grid/","text":"Grid \u00b6 The grid submodule contains a public-facing version of the internal grid used in the Unscripted minigame core. The world grid is a two-dimensional array (list of lists) that contain strings that determine what element is present at the specific row and column. The main class responsible for working with the grid, CSWorldGrid , is a clean and lightweight implementation of this grid with multiple utilities to manage it. The grid implementation is not dependent on the numpy library and is geared towards accessing elements and other information, rather than mathematical operations. CSWorldGrid \u00b6 A class representation of a grid. The grid is a two-dimensional array object that contains elements at given positions. This class contains methods that allow easy access to the contents of the grid without needing to access the grid directly. Attributes \u00b6 grid (list): The two-dimensional array containing items at given positions, organized by row and column. __init__ \u00b6 Construct a grid. If a filter is supplied with the grid, the grid will filter for the items specified in the filter expression, marking those that don't match the filter as None. Arguments \u00b6 grid (list): The two-dimensional array representing the grid. grid_filter (callable): A function that determines what items in the grid to keep. Defaults to None, indicating that no filter is applied. shape() \u00b6 Get the shape of the grid. Returns \u00b6 shape (tuple): A tuple containing the total rows and columns of this grid. as_list() \u00b6 Convert the grid to a list of coordinates containing a non-void item. Note: If a filter was applied to the grid at construction, it will only select items that are not None . Returns \u00b6 coordinates (list): A list of tuples containing the coordinates to valid items in the grid. first(of=\"\") \u00b6 Get the first instance of an item in the grid. Arguments \u00b6 of (str): The item to look for the first instance of in this grid. Returns \u00b6 coords (tuple): A tuple containing the row and column coordinates of the first item. If the item was not found, the tuple -1, -1 is returned. last(of=\"\") \u00b6 Get the last instance of an item in the grid. Arguments \u00b6 of (str): The item to look for the last instance of in this grid. Returns \u00b6 coords (tuple): A tuple containing the row and column coordinates of the last item. If the item was not found, the tuple -1, -1 is returned. element_at(row, column) \u00b6 Get the element at a specified position. Arguments \u00b6 row (int): The row that the element is located in column (int): The column that the element is located in Returns \u00b6 element (str): The element at the specified position in the grid.","title":"Grid"},{"location":"fira/api/grid/#grid","text":"The grid submodule contains a public-facing version of the internal grid used in the Unscripted minigame core. The world grid is a two-dimensional array (list of lists) that contain strings that determine what element is present at the specific row and column. The main class responsible for working with the grid, CSWorldGrid , is a clean and lightweight implementation of this grid with multiple utilities to manage it. The grid implementation is not dependent on the numpy library and is geared towards accessing elements and other information, rather than mathematical operations.","title":"Grid"},{"location":"fira/api/grid/#csworldgrid","text":"A class representation of a grid. The grid is a two-dimensional array object that contains elements at given positions. This class contains methods that allow easy access to the contents of the grid without needing to access the grid directly.","title":"CSWorldGrid"},{"location":"fira/api/grid/#attributes","text":"grid (list): The two-dimensional array containing items at given positions, organized by row and column.","title":"Attributes"},{"location":"fira/api/grid/#__init__","text":"Construct a grid. If a filter is supplied with the grid, the grid will filter for the items specified in the filter expression, marking those that don't match the filter as None.","title":"__init__"},{"location":"fira/api/grid/#arguments","text":"grid (list): The two-dimensional array representing the grid. grid_filter (callable): A function that determines what items in the grid to keep. Defaults to None, indicating that no filter is applied.","title":"Arguments"},{"location":"fira/api/grid/#shape","text":"Get the shape of the grid.","title":"shape()"},{"location":"fira/api/grid/#returns","text":"shape (tuple): A tuple containing the total rows and columns of this grid.","title":"Returns"},{"location":"fira/api/grid/#as_list","text":"Convert the grid to a list of coordinates containing a non-void item. Note: If a filter was applied to the grid at construction, it will only select items that are not None .","title":"as_list()"},{"location":"fira/api/grid/#returns_1","text":"coordinates (list): A list of tuples containing the coordinates to valid items in the grid.","title":"Returns"},{"location":"fira/api/grid/#firstof","text":"Get the first instance of an item in the grid.","title":"first(of=\"\")"},{"location":"fira/api/grid/#arguments_1","text":"of (str): The item to look for the first instance of in this grid.","title":"Arguments"},{"location":"fira/api/grid/#returns_2","text":"coords (tuple): A tuple containing the row and column coordinates of the first item. If the item was not found, the tuple -1, -1 is returned.","title":"Returns"},{"location":"fira/api/grid/#lastof","text":"Get the last instance of an item in the grid.","title":"last(of=\"\")"},{"location":"fira/api/grid/#arguments_2","text":"of (str): The item to look for the last instance of in this grid.","title":"Arguments"},{"location":"fira/api/grid/#returns_3","text":"coords (tuple): A tuple containing the row and column coordinates of the last item. If the item was not found, the tuple -1, -1 is returned.","title":"Returns"},{"location":"fira/api/grid/#element_atrow-column","text":"Get the element at a specified position.","title":"element_at(row, column)"},{"location":"fira/api/grid/#arguments_3","text":"row (int): The row that the element is located in column (int): The column that the element is located in","title":"Arguments"},{"location":"fira/api/grid/#returns_4","text":"element (str): The element at the specified position in the grid.","title":"Returns"},{"location":"fira/api/info/","text":"Info \u00b6 The info submodule contains the utilities to get the world and player information for a given level. Methods \u00b6 get_level_information(level) \u00b6 Create a world and player based on a game level. Unsupported Method This function may no longer be supported in future releases of the Fira API and may cause unexpected results. It is recommended to use MinigameLevel instead of this function when possible. Arguments \u00b6 level (int): The level number as indicated by the minigame. fn_path (str): The path to where the NadiaVM file will be written to. This excludes the file name itself. **kwargs (dict): Arbitrary keyword arguments. Kwargs \u00b6 config_file (str): The path to the level configuration file, excluding the file name. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object. Returns \u00b6 info (tuple): A tuple containing the CSPlayer object and the CSWorld object Classes \u00b6 MinigameLevel \u00b6 A class representation of a minigame level. This class is designed to be used with the with argument as a means to directly write virtual machine code without any abstraction involved. When used in a context with the with statement, the minigame level class may also return the configuration data for the level. This can be used to programmatically determine what needs to be written as VM code. Example with MinigameLevel(1) as vm, data: devices = data.devices().as_list() vm.alloc(\"world_coins\", len(devices)) vm.alloc(\"inventory\", len(devices)) for device in devices: vm.set(device) vm.push(\"world_coins\", devices.index(device)) __init__(self, level, vm_path, provide_config=False, **kwargs) \u00b6 Initialize a minigame level reader. Args \u00b6 level (int): The level number to read. vm_path (str): The path to the compiled NadiaVM file to write. provide_config (bool): Whether to include the configuration file while accessing the writer. Defaults to False. **kwargs (dict): Arbitrary keyword arguments. Kwargs \u00b6 config_file (str): The path to the level configuration file, excluding the file name. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object. startfile(self) \u00b6 Start the writing process. Returns \u00b6 data (tuple): A tuple that contains the virtual machine writer ( uvn_fira.api.vm.CSMinigameWriter ) and the game data ( CSWorldData ). close(self) \u00b6 Write the contents of the virtual machine code to the requested file.","title":"Info"},{"location":"fira/api/info/#info","text":"The info submodule contains the utilities to get the world and player information for a given level.","title":"Info"},{"location":"fira/api/info/#methods","text":"","title":"Methods"},{"location":"fira/api/info/#get_level_informationlevel","text":"Create a world and player based on a game level. Unsupported Method This function may no longer be supported in future releases of the Fira API and may cause unexpected results. It is recommended to use MinigameLevel instead of this function when possible.","title":"get_level_information(level)"},{"location":"fira/api/info/#arguments","text":"level (int): The level number as indicated by the minigame. fn_path (str): The path to where the NadiaVM file will be written to. This excludes the file name itself. **kwargs (dict): Arbitrary keyword arguments.","title":"Arguments"},{"location":"fira/api/info/#kwargs","text":"config_file (str): The path to the level configuration file, excluding the file name. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object.","title":"Kwargs"},{"location":"fira/api/info/#returns","text":"info (tuple): A tuple containing the CSPlayer object and the CSWorld object","title":"Returns"},{"location":"fira/api/info/#classes","text":"","title":"Classes"},{"location":"fira/api/info/#minigamelevel","text":"A class representation of a minigame level. This class is designed to be used with the with argument as a means to directly write virtual machine code without any abstraction involved. When used in a context with the with statement, the minigame level class may also return the configuration data for the level. This can be used to programmatically determine what needs to be written as VM code. Example with MinigameLevel(1) as vm, data: devices = data.devices().as_list() vm.alloc(\"world_coins\", len(devices)) vm.alloc(\"inventory\", len(devices)) for device in devices: vm.set(device) vm.push(\"world_coins\", devices.index(device))","title":"MinigameLevel"},{"location":"fira/api/info/#__init__self-level-vm_path-provide_configfalse-kwargs","text":"Initialize a minigame level reader.","title":"__init__(self, level, vm_path, provide_config=False, **kwargs)"},{"location":"fira/api/info/#args","text":"level (int): The level number to read. vm_path (str): The path to the compiled NadiaVM file to write. provide_config (bool): Whether to include the configuration file while accessing the writer. Defaults to False. **kwargs (dict): Arbitrary keyword arguments.","title":"Args"},{"location":"fira/api/info/#kwargs_1","text":"config_file (str): The path to the level configuration file, excluding the file name. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object.","title":"Kwargs"},{"location":"fira/api/info/#startfileself","text":"Start the writing process.","title":"startfile(self)"},{"location":"fira/api/info/#returns_1","text":"data (tuple): A tuple that contains the virtual machine writer ( uvn_fira.api.vm.CSMinigameWriter ) and the game data ( CSWorldData ).","title":"Returns"},{"location":"fira/api/info/#closeself","text":"Write the contents of the virtual machine code to the requested file.","title":"close(self)"},{"location":"fira/api/player/","text":"Player \u00b6 The player module contains the functions and classes necessary to manipulate players in a minigame world. The module contains a class that lets players control the behavior of their minigame counterpart by moving in a given direction, collecting an item, etc. ( CSPlayer ). To prevent accidental manipulation of the original world data, the player class uses its own position property to update its location. CSPlayer \u00b6 The base class for a player in the minigame world. The player object contains methods for manipulating the current player's position and inventory system. __init__ \u00b6 Construct the Player object. Arguments \u00b6 in_world ( CSWorld ): The world the player is located in. **kwargs (dict): Arbitrary keyword arguments. Kwargs \u00b6 at_position (tuple): The position the player should be placed in. Defaults to the player position in the world ( CSWorld.player ). with_inv (list): A list containing items that the player will have to start. Defaults to an empty list. vm : The virtual machine writer, if available. location() \u00b6 Get the player's current position. Returns \u00b6 position (tuple): The current coordinates of the player. origin() \u00b6 Get the original starting position of the player. Returns \u00b6 origin (tuple): The coordinates of the player's original position. capacity() \u00b6 Get the the count of how many items the player has. Returns \u00b6 count (int): The number of items in the inventory. blocked() \u00b6 Determine whether a player is blocked at a given position. Returns \u00b6 blocked (bool): True if any walls are near the player (1-block radius). move(direction) \u00b6 Move the player in a direction, if the direction results in the player being able to move into a non-walled area. Arguments \u00b6 direction (str): The direction the player should move in. Acceptable directions are \"north\" , \"south\" , \"east\" , and \"west\" . Returns \u00b6 player ( CSPlayer ): The Player that committed the move action. This is useful in cases where chaining methods is preferred. collect() \u00b6 Add an item into the player's inventory at the player's current position. If the item does not exist in the world, or the player already has the item in question, nothing occurs. Removed This method is no longer available since Fira v2.0.0. Use CSPlayer.toggle instead. Returns \u00b6 player ( CSPlayer ): The Player object that committed the collect action. This is useful in cases where chaining methods is preferred. toggle() \u00b6 Turn a nearby computer on or off. If there isn't a device to turn on, nothing occurs. Returns \u00b6 player ( CSPlayer ): The Player object that committed the toggle action. This is useful in cases where chaining methods is preferred. finish() \u00b6 Finish all instructions and compile the VM code. Migrating from v1.x In previous versions of the Fira API, this method was called exit() .","title":"Player"},{"location":"fira/api/player/#player","text":"The player module contains the functions and classes necessary to manipulate players in a minigame world. The module contains a class that lets players control the behavior of their minigame counterpart by moving in a given direction, collecting an item, etc. ( CSPlayer ). To prevent accidental manipulation of the original world data, the player class uses its own position property to update its location.","title":"Player"},{"location":"fira/api/player/#csplayer","text":"The base class for a player in the minigame world. The player object contains methods for manipulating the current player's position and inventory system.","title":"CSPlayer"},{"location":"fira/api/player/#__init__","text":"Construct the Player object.","title":"__init__"},{"location":"fira/api/player/#arguments","text":"in_world ( CSWorld ): The world the player is located in. **kwargs (dict): Arbitrary keyword arguments.","title":"Arguments"},{"location":"fira/api/player/#kwargs","text":"at_position (tuple): The position the player should be placed in. Defaults to the player position in the world ( CSWorld.player ). with_inv (list): A list containing items that the player will have to start. Defaults to an empty list. vm : The virtual machine writer, if available.","title":"Kwargs"},{"location":"fira/api/player/#location","text":"Get the player's current position.","title":"location()"},{"location":"fira/api/player/#returns","text":"position (tuple): The current coordinates of the player.","title":"Returns"},{"location":"fira/api/player/#origin","text":"Get the original starting position of the player.","title":"origin()"},{"location":"fira/api/player/#returns_1","text":"origin (tuple): The coordinates of the player's original position.","title":"Returns"},{"location":"fira/api/player/#capacity","text":"Get the the count of how many items the player has.","title":"capacity()"},{"location":"fira/api/player/#returns_2","text":"count (int): The number of items in the inventory.","title":"Returns"},{"location":"fira/api/player/#blocked","text":"Determine whether a player is blocked at a given position.","title":"blocked()"},{"location":"fira/api/player/#returns_3","text":"blocked (bool): True if any walls are near the player (1-block radius).","title":"Returns"},{"location":"fira/api/player/#movedirection","text":"Move the player in a direction, if the direction results in the player being able to move into a non-walled area.","title":"move(direction)"},{"location":"fira/api/player/#arguments_1","text":"direction (str): The direction the player should move in. Acceptable directions are \"north\" , \"south\" , \"east\" , and \"west\" .","title":"Arguments"},{"location":"fira/api/player/#returns_4","text":"player ( CSPlayer ): The Player that committed the move action. This is useful in cases where chaining methods is preferred.","title":"Returns"},{"location":"fira/api/player/#collect","text":"Add an item into the player's inventory at the player's current position. If the item does not exist in the world, or the player already has the item in question, nothing occurs. Removed This method is no longer available since Fira v2.0.0. Use CSPlayer.toggle instead.","title":"collect()"},{"location":"fira/api/player/#returns_5","text":"player ( CSPlayer ): The Player object that committed the collect action. This is useful in cases where chaining methods is preferred.","title":"Returns"},{"location":"fira/api/player/#toggle","text":"Turn a nearby computer on or off. If there isn't a device to turn on, nothing occurs.","title":"toggle()"},{"location":"fira/api/player/#returns_6","text":"player ( CSPlayer ): The Player object that committed the toggle action. This is useful in cases where chaining methods is preferred.","title":"Returns"},{"location":"fira/api/player/#finish","text":"Finish all instructions and compile the VM code. Migrating from v1.x In previous versions of the Fira API, this method was called exit() .","title":"finish()"},{"location":"fira/api/vm/","text":"The vm submodule contains a public-facing version of the virtual machine author from the Core. The VM writer is often used when using the uvn_fira.api.info.MinigameLevel class to quickly write virtual machine code in a low-level environment. The writer is an implementation for NadiaVM and is supported in the basic and advanced modes of the game. About NadiaVM \u00b6 NadiaVM is a simple, stack-based virtual machine with a couple of commands. The VM is designed to focus specifically on the minigame\u2019s internal game logic and is not necessarily suitable for general use. NadiaVM files are registered with the file extension .nvm and are typically plain text files with the corresponding instructions. Virtual Machine Commands \u00b6 In the NadiaVM, there are several commands that players can use: alloc (str) (int) : Create a new array with a name and a specific size. collect : Collect a coin in the world. Acts like a pause in VM. push (str) (int) : Push the top of the stack to the given array at the index. pop (str) (int) : Pop the item located at the array's index and move it to the top of the stack. set constant (any) : Set the top of the stack to a constant value. move player (str) : Move the player in a given direction. bind (str) (command) : Makes an alias of the command to the assigned string. cast (str) (any) : Cast the value to the given name. If a value is already cast to the name, the new value will be used instead of the old one. exit player : Try to end the execution script and finish the level. add : Add the two topmost values on the stack. sub : Subtract the two topmost values on the stack. mult : Multiply the two topmost values on the stack. div : Divide the two topmost values on the stack. neg : Negate the topmost value on the stack. Effectively the same as pushing -1 on the stack and calling mult . The VM writer presented here provides abstracted versions of these commands that will be written to the requested path. CSMinigameWriter \u00b6 A list-based implementation of the NadiaVM file writer. This class is similar to CSNadaVMWriter and contains the same methods; however, CSNadiaVMWriterBuilder uses a list to store its code rather the string that CSNadiaVMWriter uses. This is useful in instances where the builder needs to remove pieces of code or work with the current set of instructions as a list. Attributes \u00b6 instructions (list): The list of VM commands to write to the VM file. __init__ \u00b6 Construct the VM writer. Arguments \u00b6 path (str): The path to the compiled NadiaVM file ( .nvm ) to write to. alloc(array_name, size=1) \u00b6 Allocate a space of memory for a given array. Arguments \u00b6 array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1. bind(name, command) \u00b6 Bind the following name to a command. Args \u00b6 name (str): The name to bind a command to. command (str): The command to bind the name to. cast(name, value) \u00b6 Cast the value to a name. Args \u00b6 name (str): The name to cast the value to. value (any): The value to cast the name to. push(array, index) \u00b6 Push the top-most item on the current stack to the given array. Arguments \u00b6 array (str): The name of the array to push to. index (int): The index of the array to push to. pop(array, index) \u00b6 Pop the item from the array at a given index and set it at the top of the execution stack. Arguments \u00b6 array (str): The array to pop an item from. index (int): The index of the item in the array to pop. set(value) \u00b6 Set the top of the stack to a constant value. Arguments \u00b6 value (any): The value to create a constant for. move(direction) \u00b6 Move the player in a given direction. Arguments \u00b6 direction (str): The direction the player will move in. collect() \u00b6 Collect. In the VM, this acts like a pause. add() \u00b6 Add the two topmost values on the stack. sub() \u00b6 Subtract the two topmost values on the stack. mult() \u00b6 Multiply the two topmost values on the stack. div() \u00b6 Divide the two topmost values on the stack. neg() \u00b6 Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult . exit() \u00b6 Try to exit the world and end execution of the script. write() \u00b6 Write the VM code to the requested file.","title":"VM"},{"location":"fira/api/vm/#about-nadiavm","text":"NadiaVM is a simple, stack-based virtual machine with a couple of commands. The VM is designed to focus specifically on the minigame\u2019s internal game logic and is not necessarily suitable for general use. NadiaVM files are registered with the file extension .nvm and are typically plain text files with the corresponding instructions.","title":"About NadiaVM"},{"location":"fira/api/vm/#virtual-machine-commands","text":"In the NadiaVM, there are several commands that players can use: alloc (str) (int) : Create a new array with a name and a specific size. collect : Collect a coin in the world. Acts like a pause in VM. push (str) (int) : Push the top of the stack to the given array at the index. pop (str) (int) : Pop the item located at the array's index and move it to the top of the stack. set constant (any) : Set the top of the stack to a constant value. move player (str) : Move the player in a given direction. bind (str) (command) : Makes an alias of the command to the assigned string. cast (str) (any) : Cast the value to the given name. If a value is already cast to the name, the new value will be used instead of the old one. exit player : Try to end the execution script and finish the level. add : Add the two topmost values on the stack. sub : Subtract the two topmost values on the stack. mult : Multiply the two topmost values on the stack. div : Divide the two topmost values on the stack. neg : Negate the topmost value on the stack. Effectively the same as pushing -1 on the stack and calling mult . The VM writer presented here provides abstracted versions of these commands that will be written to the requested path.","title":"Virtual Machine Commands"},{"location":"fira/api/vm/#csminigamewriter","text":"A list-based implementation of the NadiaVM file writer. This class is similar to CSNadaVMWriter and contains the same methods; however, CSNadiaVMWriterBuilder uses a list to store its code rather the string that CSNadiaVMWriter uses. This is useful in instances where the builder needs to remove pieces of code or work with the current set of instructions as a list.","title":"CSMinigameWriter"},{"location":"fira/api/vm/#attributes","text":"instructions (list): The list of VM commands to write to the VM file.","title":"Attributes"},{"location":"fira/api/vm/#__init__","text":"Construct the VM writer.","title":"__init__"},{"location":"fira/api/vm/#arguments","text":"path (str): The path to the compiled NadiaVM file ( .nvm ) to write to.","title":"Arguments"},{"location":"fira/api/vm/#allocarray_name-size1","text":"Allocate a space of memory for a given array.","title":"alloc(array_name, size=1)"},{"location":"fira/api/vm/#arguments_1","text":"array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1.","title":"Arguments"},{"location":"fira/api/vm/#bindname-command","text":"Bind the following name to a command.","title":"bind(name, command)"},{"location":"fira/api/vm/#args","text":"name (str): The name to bind a command to. command (str): The command to bind the name to.","title":"Args"},{"location":"fira/api/vm/#castname-value","text":"Cast the value to a name.","title":"cast(name, value)"},{"location":"fira/api/vm/#args_1","text":"name (str): The name to cast the value to. value (any): The value to cast the name to.","title":"Args"},{"location":"fira/api/vm/#pusharray-index","text":"Push the top-most item on the current stack to the given array.","title":"push(array, index)"},{"location":"fira/api/vm/#arguments_2","text":"array (str): The name of the array to push to. index (int): The index of the array to push to.","title":"Arguments"},{"location":"fira/api/vm/#poparray-index","text":"Pop the item from the array at a given index and set it at the top of the execution stack.","title":"pop(array, index)"},{"location":"fira/api/vm/#arguments_3","text":"array (str): The array to pop an item from. index (int): The index of the item in the array to pop.","title":"Arguments"},{"location":"fira/api/vm/#setvalue","text":"Set the top of the stack to a constant value.","title":"set(value)"},{"location":"fira/api/vm/#arguments_4","text":"value (any): The value to create a constant for.","title":"Arguments"},{"location":"fira/api/vm/#movedirection","text":"Move the player in a given direction.","title":"move(direction)"},{"location":"fira/api/vm/#arguments_5","text":"direction (str): The direction the player will move in.","title":"Arguments"},{"location":"fira/api/vm/#collect","text":"Collect. In the VM, this acts like a pause.","title":"collect()"},{"location":"fira/api/vm/#add","text":"Add the two topmost values on the stack.","title":"add()"},{"location":"fira/api/vm/#sub","text":"Subtract the two topmost values on the stack.","title":"sub()"},{"location":"fira/api/vm/#mult","text":"Multiply the two topmost values on the stack.","title":"mult()"},{"location":"fira/api/vm/#div","text":"Divide the two topmost values on the stack.","title":"div()"},{"location":"fira/api/vm/#neg","text":"Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult .","title":"neg()"},{"location":"fira/api/vm/#exit","text":"Try to exit the world and end execution of the script.","title":"exit()"},{"location":"fira/api/vm/#write","text":"Write the VM code to the requested file.","title":"write()"},{"location":"fira/api/world/","text":"World \u00b6 The world module contains all of the classes and functions necessary to visualize and gather information about the game world. The module contains the base grid class responsible for making two-dimensional arrays organized like a grid easier to work with ( CSWorldGrid ), as well as the world class that contains all of the world's information such as the player's position and coins ( CSWorld ). World Implementation \u00b6 Worlds are organized as a grid-like, two-dimensional array (matrix) consisting of rows and columns. Each element in the grid contains a string that describes what the world element at that position in the grid is. There are five possible options: \"PLAYER\" , which refers to the player character \"WALL\" , which refers to a wall \"COIN\" , which refers to a collectable coin \"EXIT\" , which refers to an exit \"AIR\" , which refers to a space that doesn't have a particular item \"VOID\" , which refers to empty space with no flooring or other materials In most scenarios, the world itself does not get modified directly since the layout of items in the world need to be preserved. The CSPlayer object in the player module of the API handles world manipulation when a world is passed into its constructor, and most scripts will make a copy of world information such as the number of coins and the player's starting position. It may be impractical in some cases to access an element in the grid directly. The CSWorldGrid class allows for the world grid to be used in a more practical manner by making common operations such as getting a list containing coordinates of a specific type of item and getting the first instance of an item easier. CSWorld \u00b6 The base class for a minigame world. The minigame world contains a matrix containing the elements used to generate that world, as well as any specific world properties like coins and exit locations. __init__ \u00b6 Construct a World object. Arguments \u00b6 from_data (CSWorldDataGenerator): The world generator used to create the world data. **kwargs : Arbitrary keyword arguments. player() \u00b6 Get the player's current location in the world. Returns \u00b6 position (tuple): The current coordinates of the player. size() \u00b6 Get the size of the world. Returns \u00b6 dimensions (tuple): A tuple containing the number of rows and columns. walls() \u00b6 Get the grid of walls in the world. Returns \u00b6 walls ( CSWorldGrid ): Grid containing only the walls. coins() \u00b6 Get the grid of coins in the world. Removed This method was removed in Fira v2.0.0. Use CSWorld.devices instead. Returns \u00b6 coins ( CSWorldGrid ): Grid containing only the coins. devices() \u00b6 Get a grid of the devices in the world. Returns \u00b6 devices ( CSWorldGrid ): Grid containing only the unpowered devices. exit() \u00b6 Get the location of the exit. Returns \u00b6 exit (tuple): A tuple containing the coordinates of the exit.","title":"World"},{"location":"fira/api/world/#world","text":"The world module contains all of the classes and functions necessary to visualize and gather information about the game world. The module contains the base grid class responsible for making two-dimensional arrays organized like a grid easier to work with ( CSWorldGrid ), as well as the world class that contains all of the world's information such as the player's position and coins ( CSWorld ).","title":"World"},{"location":"fira/api/world/#world-implementation","text":"Worlds are organized as a grid-like, two-dimensional array (matrix) consisting of rows and columns. Each element in the grid contains a string that describes what the world element at that position in the grid is. There are five possible options: \"PLAYER\" , which refers to the player character \"WALL\" , which refers to a wall \"COIN\" , which refers to a collectable coin \"EXIT\" , which refers to an exit \"AIR\" , which refers to a space that doesn't have a particular item \"VOID\" , which refers to empty space with no flooring or other materials In most scenarios, the world itself does not get modified directly since the layout of items in the world need to be preserved. The CSPlayer object in the player module of the API handles world manipulation when a world is passed into its constructor, and most scripts will make a copy of world information such as the number of coins and the player's starting position. It may be impractical in some cases to access an element in the grid directly. The CSWorldGrid class allows for the world grid to be used in a more practical manner by making common operations such as getting a list containing coordinates of a specific type of item and getting the first instance of an item easier.","title":"World Implementation"},{"location":"fira/api/world/#csworld","text":"The base class for a minigame world. The minigame world contains a matrix containing the elements used to generate that world, as well as any specific world properties like coins and exit locations.","title":"CSWorld"},{"location":"fira/api/world/#__init__","text":"Construct a World object.","title":"__init__"},{"location":"fira/api/world/#arguments","text":"from_data (CSWorldDataGenerator): The world generator used to create the world data. **kwargs : Arbitrary keyword arguments.","title":"Arguments"},{"location":"fira/api/world/#player","text":"Get the player's current location in the world.","title":"player()"},{"location":"fira/api/world/#returns","text":"position (tuple): The current coordinates of the player.","title":"Returns"},{"location":"fira/api/world/#size","text":"Get the size of the world.","title":"size()"},{"location":"fira/api/world/#returns_1","text":"dimensions (tuple): A tuple containing the number of rows and columns.","title":"Returns"},{"location":"fira/api/world/#walls","text":"Get the grid of walls in the world.","title":"walls()"},{"location":"fira/api/world/#returns_2","text":"walls ( CSWorldGrid ): Grid containing only the walls.","title":"Returns"},{"location":"fira/api/world/#coins","text":"Get the grid of coins in the world. Removed This method was removed in Fira v2.0.0. Use CSWorld.devices instead.","title":"coins()"},{"location":"fira/api/world/#returns_3","text":"coins ( CSWorldGrid ): Grid containing only the coins.","title":"Returns"},{"location":"fira/api/world/#devices","text":"Get a grid of the devices in the world.","title":"devices()"},{"location":"fira/api/world/#returns_4","text":"devices ( CSWorldGrid ): Grid containing only the unpowered devices.","title":"Returns"},{"location":"fira/api/world/#exit","text":"Get the location of the exit.","title":"exit()"},{"location":"fira/api/world/#returns_5","text":"exit (tuple): A tuple containing the coordinates of the exit.","title":"Returns"},{"location":"fira/core/","text":"Core Utilities \u00b6 The core module contains the utilities, functions, and classes that control the primary logic for the Unscripted minigame.","title":"Core Utilities"},{"location":"fira/core/#core-utilities","text":"The core module contains the utilities, functions, and classes that control the primary logic for the Unscripted minigame.","title":"Core Utilities"},{"location":"fira/core/config/","text":"Configuration \u00b6 This submodule contains the configuration system for reading worlds. CSWorldConfigGenerateError(Exception) \u00b6 Could not generate the world from the requested file or configuration. CSWorldConfigReader \u00b6 he world configuration reader. The world configuration reader parses a TOML file and creates an object that stores information about the world that can be used to generate a map. Attributes \u00b6 title : The title of the map. checks : A list of strings containing the requirements for completing the puzzle. allowed : A list containing the allowed blocks for a given world. Unnecessary if using Advanced Mode. data : A CSWorldDataGenerator containing the world data from the generated map that can be used to generate a world. __init__(filepath=\"\") \u00b6 Construct the configuration reader. Arguments \u00b6 filepath (str) : The path to the configuration file to generate the world from. Defaults to an empty string. **kwargs : Arbitrary keyword arguments. Kwargs \u00b6 title (str): The title of the map. checks (list): A list containing the checks for this particular level. allowed (list): A list containing the allowed blocks in basic mode. world (str): A string representation of the world layout. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object.","title":"Configuration"},{"location":"fira/core/config/#configuration","text":"This submodule contains the configuration system for reading worlds.","title":"Configuration"},{"location":"fira/core/config/#csworldconfiggenerateerrorexception","text":"Could not generate the world from the requested file or configuration.","title":"CSWorldConfigGenerateError(Exception)"},{"location":"fira/core/config/#csworldconfigreader","text":"he world configuration reader. The world configuration reader parses a TOML file and creates an object that stores information about the world that can be used to generate a map.","title":"CSWorldConfigReader"},{"location":"fira/core/config/#attributes","text":"title : The title of the map. checks : A list of strings containing the requirements for completing the puzzle. allowed : A list containing the allowed blocks for a given world. Unnecessary if using Advanced Mode. data : A CSWorldDataGenerator containing the world data from the generated map that can be used to generate a world.","title":"Attributes"},{"location":"fira/core/config/#__init__filepath","text":"Construct the configuration reader.","title":"__init__(filepath=\"\")"},{"location":"fira/core/config/#arguments","text":"filepath (str) : The path to the configuration file to generate the world from. Defaults to an empty string. **kwargs : Arbitrary keyword arguments.","title":"Arguments"},{"location":"fira/core/config/#kwargs","text":"title (str): The title of the map. checks (list): A list containing the checks for this particular level. allowed (list): A list containing the allowed blocks in basic mode. world (str): A string representation of the world layout. exists (callable): The function to use, if not relying on the built-in os module to determine whether the configuration file path is loadable. load (callable): The function to use, if not relying on the the built-in open function to load the file object.","title":"Kwargs"},{"location":"fira/core/data/","text":"Data \u00b6 This submodule contains the world data generator code for the configuration system. CSWorldDataGenerateError(Exception) \u00b6 Could not generate the world data. CSWorldDataGenerator \u00b6 The base class for the world data generator for world maps. The world data generator reads the given input string and returns a grid-like two-dimensional array for use with world manipulation or storage. __init__ \u00b6 Construct the world data generator. Arguments \u00b6 data (str): The string containing the world's data to parse. Defaults to an empty string. size() \u00b6 Get the size of the given world data grid. Returns \u00b6 dimensions (tuple): A tuple containing the number of rows and columns in the grid. to_grid() \u00b6 Get the world data as a world grid. Returns \u00b6 grid ( CSGrid ): A world grid containing the world data. coins() \u00b6 Get the world coin data. Returns \u00b6 grid ( CSGrid ): The world grid containing the coins. walls() \u00b6 Get the world wall data. Returns \u00b6 grid ( CSGrid ): The world grid containing the walls.","title":"Data"},{"location":"fira/core/data/#data","text":"This submodule contains the world data generator code for the configuration system.","title":"Data"},{"location":"fira/core/data/#csworlddatagenerateerrorexception","text":"Could not generate the world data.","title":"CSWorldDataGenerateError(Exception)"},{"location":"fira/core/data/#csworlddatagenerator","text":"The base class for the world data generator for world maps. The world data generator reads the given input string and returns a grid-like two-dimensional array for use with world manipulation or storage.","title":"CSWorldDataGenerator"},{"location":"fira/core/data/#__init__","text":"Construct the world data generator.","title":"__init__"},{"location":"fira/core/data/#arguments","text":"data (str): The string containing the world's data to parse. Defaults to an empty string.","title":"Arguments"},{"location":"fira/core/data/#size","text":"Get the size of the given world data grid.","title":"size()"},{"location":"fira/core/data/#returns","text":"dimensions (tuple): A tuple containing the number of rows and columns in the grid.","title":"Returns"},{"location":"fira/core/data/#to_grid","text":"Get the world data as a world grid.","title":"to_grid()"},{"location":"fira/core/data/#returns_1","text":"grid ( CSGrid ): A world grid containing the world data.","title":"Returns"},{"location":"fira/core/data/#coins","text":"Get the world coin data.","title":"coins()"},{"location":"fira/core/data/#returns_2","text":"grid ( CSGrid ): The world grid containing the coins.","title":"Returns"},{"location":"fira/core/data/#walls","text":"Get the world wall data.","title":"walls()"},{"location":"fira/core/data/#returns_3","text":"grid ( CSGrid ): The world grid containing the walls.","title":"Returns"},{"location":"fira/core/grid/","text":"This submodule contains the grid data type used in the minigame world. CSGrid \u00b6 A class representation of a grid. The grid is a two-dimensional array object that contains elements at given positions. This class contains methods that allow easy access to the contents of the grid without needing to access the grid directly. Attributes \u00b6 grid (list): The two-dimensional array containing items at given positions, organized by row and column. __init__ \u00b6 Construct a grid. If a filter is supplied with the grid, the grid will filter for the items specified in the filter expression, marking those that don't match the filter as None. Arguments \u00b6 grid (list): The two-dimensional array representing the grid. grid_filter (callable): A function that determines what items in the grid to keep. Defaults to None, indicating that no filter is applied. shape() \u00b6 Get the shape of the grid. Returns \u00b6 shape (tuple): A tuple containing the total rows and columns of this grid. as_list() \u00b6 Convert the grid to a list of coordinates containing a non-void item. Note: If a filter was applied to the grid at construction, it will only select items that are not None . Returns \u00b6 coordinates (list): A list of tuples containing the coordinates to valid items in the grid. first(of=\"\") \u00b6 Get the first instance of an item in the grid. Arguments \u00b6 of (str): The item to look for the first instance of in this grid. Returns \u00b6 coords (tuple): A tuple containing the row and column coordinates of the first item. If the item was not found, the tuple -1, -1 is returned. last(of=\"\") \u00b6 Get the last instance of an item in the grid. Arguments \u00b6 of (str): The item to look for the last instance of in this grid. Returns \u00b6 coords (tuple): A tuple containing the row and column coordinates of the last item. If the item was not found, the tuple -1, -1 is returned. element_at(row, column) \u00b6 Get the element at a specified position. Arguments \u00b6 row (int): The row that the element is located in column (int): The column that the element is located in Returns \u00b6 element (str): The element at the specified position in the grid.","title":"Grid"},{"location":"fira/core/grid/#csgrid","text":"A class representation of a grid. The grid is a two-dimensional array object that contains elements at given positions. This class contains methods that allow easy access to the contents of the grid without needing to access the grid directly.","title":"CSGrid"},{"location":"fira/core/grid/#attributes","text":"grid (list): The two-dimensional array containing items at given positions, organized by row and column.","title":"Attributes"},{"location":"fira/core/grid/#__init__","text":"Construct a grid. If a filter is supplied with the grid, the grid will filter for the items specified in the filter expression, marking those that don't match the filter as None.","title":"__init__"},{"location":"fira/core/grid/#arguments","text":"grid (list): The two-dimensional array representing the grid. grid_filter (callable): A function that determines what items in the grid to keep. Defaults to None, indicating that no filter is applied.","title":"Arguments"},{"location":"fira/core/grid/#shape","text":"Get the shape of the grid.","title":"shape()"},{"location":"fira/core/grid/#returns","text":"shape (tuple): A tuple containing the total rows and columns of this grid.","title":"Returns"},{"location":"fira/core/grid/#as_list","text":"Convert the grid to a list of coordinates containing a non-void item. Note: If a filter was applied to the grid at construction, it will only select items that are not None .","title":"as_list()"},{"location":"fira/core/grid/#returns_1","text":"coordinates (list): A list of tuples containing the coordinates to valid items in the grid.","title":"Returns"},{"location":"fira/core/grid/#firstof","text":"Get the first instance of an item in the grid.","title":"first(of=\"\")"},{"location":"fira/core/grid/#arguments_1","text":"of (str): The item to look for the first instance of in this grid.","title":"Arguments"},{"location":"fira/core/grid/#returns_2","text":"coords (tuple): A tuple containing the row and column coordinates of the first item. If the item was not found, the tuple -1, -1 is returned.","title":"Returns"},{"location":"fira/core/grid/#lastof","text":"Get the last instance of an item in the grid.","title":"last(of=\"\")"},{"location":"fira/core/grid/#arguments_2","text":"of (str): The item to look for the last instance of in this grid.","title":"Arguments"},{"location":"fira/core/grid/#returns_3","text":"coords (tuple): A tuple containing the row and column coordinates of the last item. If the item was not found, the tuple -1, -1 is returned.","title":"Returns"},{"location":"fira/core/grid/#element_atrow-column","text":"Get the element at a specified position.","title":"element_at(row, column)"},{"location":"fira/core/grid/#arguments_3","text":"row (int): The row that the element is located in column (int): The column that the element is located in","title":"Arguments"},{"location":"fira/core/grid/#returns_4","text":"element (str): The element at the specified position in the grid.","title":"Returns"},{"location":"fira/core/template/","text":"Templates \u00b6 The template module contains the utilities to create file templates for the Unscripted minigame code. The template files are generated when the game starts and are replaced if none are found. Methods \u00b6 generate_template(filepath, for_level=0) \u00b6 Generate a template file using the Minigame APIs. Arguments \u00b6 filepath (str): The path to where the template file will be written. for_level (int): The corresponding level for the minigame. Defaults to 0.","title":"Templates"},{"location":"fira/core/template/#templates","text":"The template module contains the utilities to create file templates for the Unscripted minigame code. The template files are generated when the game starts and are replaced if none are found.","title":"Templates"},{"location":"fira/core/template/#methods","text":"","title":"Methods"},{"location":"fira/core/template/#generate_templatefilepath-for_level0","text":"Generate a template file using the Minigame APIs.","title":"generate_template(filepath, for_level=0)"},{"location":"fira/core/template/#arguments","text":"filepath (str): The path to where the template file will be written. for_level (int): The corresponding level for the minigame. Defaults to 0.","title":"Arguments"},{"location":"fira/core/vm/","text":"Virtual Machine \u00b6 This submodule contains the low-level virtual machine reader for the minigame code. Implementation \u00b6 The Unscripted API and the minigame GUI eventually write files readable by the Nadia Virtual Machine (NVM). The Nadia Virtual Machine is a stack-based virtual machine designed to perform operations specific to the Unscripted minigame. CSNadiaVMCommandNotFoundError(Exception) \u00b6 VM command not found. CSNadiaVM \u00b6 An implementation of the NadiaVM stack. __init__ \u00b6 Construct the VM reader. Arguments \u00b6 path (str): The path to the compiled NadiaVM file ( .nvm ) to read from. pl (tuple): The coordinates of the player. has_more_instructions() \u00b6 Determine if the VM has more instructions to execute. Returns \u00b6 more (bool): Boolean that will be True if there are more instructions, False otherwise. preview_next_instruction() \u00b6 Get the next command in the instruction list without executing it in the VM. Returns \u00b6 command (str): The command to be executed, excluding parameters, or None if there are no more instructions to execute in the VM. next() \u00b6 Execute the next instruction in the VM code. Raises \u00b6 error ( CSNadiaVMCommandNotFoundError ): Command not found. get(name) \u00b6 Get the specified item in the virtual machine. Arguments \u00b6 name (str): The name of the item to get. Returns \u00b6 array (list): The specified item, or None if it doesn't exist. pos \u00b6 Get the current player position from the VM execution stack. Returns \u00b6 player (tuple): A tuple containing the coordinates of the player. CSNadiaVMWriterBuilder \u00b6 An list-based implementation of the NadiaVM file writer. This class is similar to CSNadaVMWriter and contains the same methods; however, CSNadiaVMWriterBuilder uses a list to store its code rather the string that CSNadiaVMWriter uses. This is useful in instances where the builder needs to remove pieces of code or work with the current set of instructions as a list. Attributes \u00b6 instructions (list): The list of VM commands to write to the VM file. __init__ \u00b6 Construct the VM writer builder. Arguments \u00b6 path (str): The path to the compiled NadiaVM file ( .nvm ) to write to. alloc(array_name, size=1) \u00b6 Allocate a space of memory for a given array. Arguments \u00b6 array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1. push(array, index) \u00b6 Push the top-most item on the current stack to the given array. Arguments \u00b6 array (str): The name of the array to push to. index (int): The index of the array to push to. pop(array, index) \u00b6 Pop the item from the array at a given index and set it at the top of the execution stack. Arguments \u00b6 array (str): The array to pop an item from. index (int): The index of the item in the array to pop. set(value) \u00b6 Set the top of the stack to a constant value. Arguments \u00b6 value (any): The value to create a constant for. move(direction) \u00b6 Move the player in a given direction. Arguments \u00b6 direction (str): The direction the player will move in. collect() \u00b6 Collect. In the VM, this acts like a pause. add() \u00b6 Add the two topmost values on the stack. sub() \u00b6 Subtract the two topmost values on the stack. mult() \u00b6 Multiply the two topmost values on the stack. div() \u00b6 Divide the two topmost values on the stack. neg() \u00b6 Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult . exit() \u00b6 Try to exit the world and end execution of the script. write() \u00b6 Write the VM code to the requested file. clear() \u00b6 Clear all of the current instructions in the VM stack. undo(ignore_collect=True) \u00b6 Remove the top of the instruction stack. Arguments \u00b6 ignore_collect (bool): Whether to ignore the pop and push statements preceding the collect statement. Defaults to True. CSNadiaVMWriter \u00b6 An implementation of the NadiaVM file writer. __init__ \u00b6 Construct the VM writer. Arguments \u00b6 path (str): The path to the compiled NadiaVM file ( .nvm ) to write to. alloc(array_name, size=1) \u00b6 Allocate a space of memory for a given array. Arguments \u00b6 array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1. push(array, index) \u00b6 Push the top-most item on the current stack to the given array. Arguments \u00b6 array (str): The name of the array to push to. index (int): The index of the array to push to. pop(array, index) \u00b6 Pop the item from the array at a given index and set it at the top of the execution stack. Arguments \u00b6 array (str): The array to pop an item from. index (int): The index of the item in the array to pop. set(value) \u00b6 Set the top of the stack to a constant value. Arguments \u00b6 value (any): The value to create a constant for. move(direction) \u00b6 Move the player in a given direction. Arguments \u00b6 direction (str): The direction the player will move in. collect() \u00b6 Collect. In the VM, this acts like a pause. add() \u00b6 Add the two topmost values on the stack. sub() \u00b6 Subtract the two topmost values on the stack. mult() \u00b6 Multiply the two topmost values on the stack. div() \u00b6 Divide the two topmost values on the stack. neg() \u00b6 Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult . exit() \u00b6 Try to exit the world and end execution of the script. write() \u00b6 Write the VM code to the requested file.","title":"Virtual Machine"},{"location":"fira/core/vm/#virtual-machine","text":"This submodule contains the low-level virtual machine reader for the minigame code.","title":"Virtual Machine"},{"location":"fira/core/vm/#implementation","text":"The Unscripted API and the minigame GUI eventually write files readable by the Nadia Virtual Machine (NVM). The Nadia Virtual Machine is a stack-based virtual machine designed to perform operations specific to the Unscripted minigame.","title":"Implementation"},{"location":"fira/core/vm/#csnadiavmcommandnotfounderrorexception","text":"VM command not found.","title":"CSNadiaVMCommandNotFoundError(Exception)"},{"location":"fira/core/vm/#csnadiavm","text":"An implementation of the NadiaVM stack.","title":"CSNadiaVM"},{"location":"fira/core/vm/#__init__","text":"Construct the VM reader.","title":"__init__"},{"location":"fira/core/vm/#arguments","text":"path (str): The path to the compiled NadiaVM file ( .nvm ) to read from. pl (tuple): The coordinates of the player.","title":"Arguments"},{"location":"fira/core/vm/#has_more_instructions","text":"Determine if the VM has more instructions to execute.","title":"has_more_instructions()"},{"location":"fira/core/vm/#returns","text":"more (bool): Boolean that will be True if there are more instructions, False otherwise.","title":"Returns"},{"location":"fira/core/vm/#preview_next_instruction","text":"Get the next command in the instruction list without executing it in the VM.","title":"preview_next_instruction()"},{"location":"fira/core/vm/#returns_1","text":"command (str): The command to be executed, excluding parameters, or None if there are no more instructions to execute in the VM.","title":"Returns"},{"location":"fira/core/vm/#next","text":"Execute the next instruction in the VM code.","title":"next()"},{"location":"fira/core/vm/#raises","text":"error ( CSNadiaVMCommandNotFoundError ): Command not found.","title":"Raises"},{"location":"fira/core/vm/#getname","text":"Get the specified item in the virtual machine.","title":"get(name)"},{"location":"fira/core/vm/#arguments_1","text":"name (str): The name of the item to get.","title":"Arguments"},{"location":"fira/core/vm/#returns_2","text":"array (list): The specified item, or None if it doesn't exist.","title":"Returns"},{"location":"fira/core/vm/#pos","text":"Get the current player position from the VM execution stack.","title":"pos"},{"location":"fira/core/vm/#returns_3","text":"player (tuple): A tuple containing the coordinates of the player.","title":"Returns"},{"location":"fira/core/vm/#csnadiavmwriterbuilder","text":"An list-based implementation of the NadiaVM file writer. This class is similar to CSNadaVMWriter and contains the same methods; however, CSNadiaVMWriterBuilder uses a list to store its code rather the string that CSNadiaVMWriter uses. This is useful in instances where the builder needs to remove pieces of code or work with the current set of instructions as a list.","title":"CSNadiaVMWriterBuilder"},{"location":"fira/core/vm/#attributes","text":"instructions (list): The list of VM commands to write to the VM file.","title":"Attributes"},{"location":"fira/core/vm/#__init___1","text":"Construct the VM writer builder.","title":"__init__"},{"location":"fira/core/vm/#arguments_2","text":"path (str): The path to the compiled NadiaVM file ( .nvm ) to write to.","title":"Arguments"},{"location":"fira/core/vm/#allocarray_name-size1","text":"Allocate a space of memory for a given array.","title":"alloc(array_name, size=1)"},{"location":"fira/core/vm/#arguments_3","text":"array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1.","title":"Arguments"},{"location":"fira/core/vm/#pusharray-index","text":"Push the top-most item on the current stack to the given array.","title":"push(array, index)"},{"location":"fira/core/vm/#arguments_4","text":"array (str): The name of the array to push to. index (int): The index of the array to push to.","title":"Arguments"},{"location":"fira/core/vm/#poparray-index","text":"Pop the item from the array at a given index and set it at the top of the execution stack.","title":"pop(array, index)"},{"location":"fira/core/vm/#arguments_5","text":"array (str): The array to pop an item from. index (int): The index of the item in the array to pop.","title":"Arguments"},{"location":"fira/core/vm/#setvalue","text":"Set the top of the stack to a constant value.","title":"set(value)"},{"location":"fira/core/vm/#arguments_6","text":"value (any): The value to create a constant for.","title":"Arguments"},{"location":"fira/core/vm/#movedirection","text":"Move the player in a given direction.","title":"move(direction)"},{"location":"fira/core/vm/#arguments_7","text":"direction (str): The direction the player will move in.","title":"Arguments"},{"location":"fira/core/vm/#collect","text":"Collect. In the VM, this acts like a pause.","title":"collect()"},{"location":"fira/core/vm/#add","text":"Add the two topmost values on the stack.","title":"add()"},{"location":"fira/core/vm/#sub","text":"Subtract the two topmost values on the stack.","title":"sub()"},{"location":"fira/core/vm/#mult","text":"Multiply the two topmost values on the stack.","title":"mult()"},{"location":"fira/core/vm/#div","text":"Divide the two topmost values on the stack.","title":"div()"},{"location":"fira/core/vm/#neg","text":"Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult .","title":"neg()"},{"location":"fira/core/vm/#exit","text":"Try to exit the world and end execution of the script.","title":"exit()"},{"location":"fira/core/vm/#write","text":"Write the VM code to the requested file.","title":"write()"},{"location":"fira/core/vm/#clear","text":"Clear all of the current instructions in the VM stack.","title":"clear()"},{"location":"fira/core/vm/#undoignore_collecttrue","text":"Remove the top of the instruction stack.","title":"undo(ignore_collect=True)"},{"location":"fira/core/vm/#arguments_8","text":"ignore_collect (bool): Whether to ignore the pop and push statements preceding the collect statement. Defaults to True.","title":"Arguments"},{"location":"fira/core/vm/#csnadiavmwriter","text":"An implementation of the NadiaVM file writer.","title":"CSNadiaVMWriter"},{"location":"fira/core/vm/#__init___2","text":"Construct the VM writer.","title":"__init__"},{"location":"fira/core/vm/#arguments_9","text":"path (str): The path to the compiled NadiaVM file ( .nvm ) to write to.","title":"Arguments"},{"location":"fira/core/vm/#allocarray_name-size1_1","text":"Allocate a space of memory for a given array.","title":"alloc(array_name, size=1)"},{"location":"fira/core/vm/#arguments_10","text":"array_name (str): The name of the array to allocate space for. size (int): The size of the array. Defaults to 1.","title":"Arguments"},{"location":"fira/core/vm/#pusharray-index_1","text":"Push the top-most item on the current stack to the given array.","title":"push(array, index)"},{"location":"fira/core/vm/#arguments_11","text":"array (str): The name of the array to push to. index (int): The index of the array to push to.","title":"Arguments"},{"location":"fira/core/vm/#poparray-index_1","text":"Pop the item from the array at a given index and set it at the top of the execution stack.","title":"pop(array, index)"},{"location":"fira/core/vm/#arguments_12","text":"array (str): The array to pop an item from. index (int): The index of the item in the array to pop.","title":"Arguments"},{"location":"fira/core/vm/#setvalue_1","text":"Set the top of the stack to a constant value.","title":"set(value)"},{"location":"fira/core/vm/#arguments_13","text":"value (any): The value to create a constant for.","title":"Arguments"},{"location":"fira/core/vm/#movedirection_1","text":"Move the player in a given direction.","title":"move(direction)"},{"location":"fira/core/vm/#arguments_14","text":"direction (str): The direction the player will move in.","title":"Arguments"},{"location":"fira/core/vm/#collect_1","text":"Collect. In the VM, this acts like a pause.","title":"collect()"},{"location":"fira/core/vm/#add_1","text":"Add the two topmost values on the stack.","title":"add()"},{"location":"fira/core/vm/#sub_1","text":"Subtract the two topmost values on the stack.","title":"sub()"},{"location":"fira/core/vm/#mult_1","text":"Multiply the two topmost values on the stack.","title":"mult()"},{"location":"fira/core/vm/#div_1","text":"Divide the two topmost values on the stack.","title":"div()"},{"location":"fira/core/vm/#neg_1","text":"Negate the topmost value on the stack. Effectively, this is the equivalent of pushing -1 onto the stack and calling mult .","title":"neg()"},{"location":"fira/core/vm/#exit_1","text":"Try to exit the world and end execution of the script.","title":"exit()"},{"location":"fira/core/vm/#write_1","text":"Write the VM code to the requested file.","title":"write()"},{"location":"simplechanges/","text":"A dead simple changelog format \u00b6 Simple Changes is a dead-simple changelog format that keeps track of changes and call them programmatically. The file format is dead-easy to follow, and you can use this package to parse the file and get information in the changelog. Simple Changes is used in Unscripted to parse the game's changelog and present the latest version information to players, but this library can be used anywhere. Getting started \u00b6 Quick Start: Install on PyPI \u00b6 Simple Changes is bundled in Unscripted, but you can install it into your projects anywhere from PyPI with pip: pip install simplechanges Install from source \u00b6 To install Simple Changes from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry. In the root of the source, run the following commands: - poetry install - poetry build The resulting wheel files will be available in the dist directory.","title":"Home"},{"location":"simplechanges/#a-dead-simple-changelog-format","text":"Simple Changes is a dead-simple changelog format that keeps track of changes and call them programmatically. The file format is dead-easy to follow, and you can use this package to parse the file and get information in the changelog. Simple Changes is used in Unscripted to parse the game's changelog and present the latest version information to players, but this library can be used anywhere.","title":"A dead simple changelog format"},{"location":"simplechanges/#getting-started","text":"","title":"Getting started"},{"location":"simplechanges/#quick-start-install-on-pypi","text":"Simple Changes is bundled in Unscripted, but you can install it into your projects anywhere from PyPI with pip: pip install simplechanges","title":"Quick Start: Install on PyPI"},{"location":"simplechanges/#install-from-source","text":"To install Simple Changes from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry. In the root of the source, run the following commands: - poetry install - poetry build The resulting wheel files will be available in the dist directory.","title":"Install from source"},{"location":"simplechanges/package/","text":"Package \u00b6 We offer an official package that parses Simple Changes files into a dictionary that contains the changelog information. Installation \u00b6 Simple Changes is bundled in Unscripted, but you can install it into your projects anywhere from PyPI with pip: pip install simplechanges Install from source \u00b6 To install Simple Changes from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry. In the root of the source, run the following commands: - poetry install - poetry build The resulting wheel files will be available in the dist directory. Usage \u00b6 To get the latest version in the changelog, assuming the changelog builds up: from simplechanges import SimpleChangesParser changelog = SimpleChangesParser(\"changelog.changes\") changelog.parse() version, notes = changelog.latest After parsing, you also can browse for a specific version: from simplechanges import SimpleChangesParser changelog = SimpleChangesParser(\"changelog.changes\") changelog.parse() version, notes = changelog.versions[\"v1.0.0\"] SimpleChangesParser \u00b6 The parser object for the Simple Changes format. Attributes \u00b6 versions \u00b6 ( dict ) The parsed changelog. latest \u00b6 ( tuple ) The latest version in the changelog and its associated notes. Methods \u00b6 parse() \u00b6 Parse the file contents into a dictionary.","title":"Python Package"},{"location":"simplechanges/package/#package","text":"We offer an official package that parses Simple Changes files into a dictionary that contains the changelog information.","title":"Package"},{"location":"simplechanges/package/#installation","text":"Simple Changes is bundled in Unscripted, but you can install it into your projects anywhere from PyPI with pip: pip install simplechanges","title":"Installation"},{"location":"simplechanges/package/#install-from-source","text":"To install Simple Changes from the source code, first clone the repository from GitHub via git clone . You'll also need to install Poetry. In the root of the source, run the following commands: - poetry install - poetry build The resulting wheel files will be available in the dist directory.","title":"Install from source"},{"location":"simplechanges/package/#usage","text":"To get the latest version in the changelog, assuming the changelog builds up: from simplechanges import SimpleChangesParser changelog = SimpleChangesParser(\"changelog.changes\") changelog.parse() version, notes = changelog.latest After parsing, you also can browse for a specific version: from simplechanges import SimpleChangesParser changelog = SimpleChangesParser(\"changelog.changes\") changelog.parse() version, notes = changelog.versions[\"v1.0.0\"]","title":"Usage"},{"location":"simplechanges/package/#simplechangesparser","text":"The parser object for the Simple Changes format.","title":"SimpleChangesParser"},{"location":"simplechanges/package/#attributes","text":"","title":"Attributes"},{"location":"simplechanges/package/#versions","text":"( dict ) The parsed changelog.","title":"versions"},{"location":"simplechanges/package/#latest","text":"( tuple ) The latest version in the changelog and its associated notes.","title":"latest"},{"location":"simplechanges/package/#methods","text":"","title":"Methods"},{"location":"simplechanges/package/#parse","text":"Parse the file contents into a dictionary.","title":"parse()"},{"location":"simplechanges/syntax/","text":"Syntax \u00b6 The syntax for a Simple Changes file (.changes) is dead-simple, mirroring that of TOML. Comments are wrapped in /* and */ . Versions are denoted by square brackets: [v1.0.0] . Notes are denoted with dashes in the beginning and end with a newline. Versions should always be organized in descending order, starting from the latest version. Our official parser package reads the changelogs in this way. Tip It is recommended to use the Simple Changes format alongside the Keep a Changelog strategy to ensure decent, human-readable changelogs. Example \u00b6 /* Project Scotia Changelog This file provides the changelog for Project Scotia. */ [v1.0.1] - Fixes a bug where System32 caused a crash when being deleted. - Updates flight manuals to latest documentation. [v1.0.0] - Initial release.","title":"Syntax"},{"location":"simplechanges/syntax/#syntax","text":"The syntax for a Simple Changes file (.changes) is dead-simple, mirroring that of TOML. Comments are wrapped in /* and */ . Versions are denoted by square brackets: [v1.0.0] . Notes are denoted with dashes in the beginning and end with a newline. Versions should always be organized in descending order, starting from the latest version. Our official parser package reads the changelogs in this way. Tip It is recommended to use the Simple Changes format alongside the Keep a Changelog strategy to ensure decent, human-readable changelogs.","title":"Syntax"},{"location":"simplechanges/syntax/#example","text":"/* Project Scotia Changelog This file provides the changelog for Project Scotia. */ [v1.0.1] - Fixes a bug where System32 caused a crash when being deleted. - Updates flight manuals to latest documentation. [v1.0.0] - Initial release.","title":"Example"}]}